
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>‰∏âÊ∂àRPG - ÈÅäÊà≤ÁïåÈù¢</title>
<style>
/* Êï¥È´îÈ†ÅÈù¢Ê®£Âºè */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #1c1c3c; /* Darker, richer blue */
    color: #e0e0e0;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    user-select: none;
    overflow: hidden;
    touch-action: none; /* Èò≤Ê≠¢ÁßªÂãïÁ´ØÊªëÂãïÊôÇÁöÑÈ†ÅÈù¢ÊªæÂãï */
}

/* ÈÅäÊà≤‰∏ªÂÆπÂô®,Ê®°Êì¨ÊâãÊ©üË±éÂ±èÊØî‰æã */
.game-wrapper {
    height: 98vh;
    max-width: 98vw;
    aspect-ratio: 1125 / 2436;
    margin: auto;
    background-color: #10101a;
    border-radius: 20px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    border: 2px solid #0f3460;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    container-type: inline-size;
    position: relative; /* For test mode indicator */
}

.game-wrapper.shake {
    animation: vibration-animation 0.2s cubic-bezier(.36,.07,.19,.97) both;
}
@keyframes vibration-animation {
    0%, 100% { transform: translate(0, 0); }
    10%, 30%, 50%, 70%, 90% { transform: translate(-1px, 1px); }
    20%, 40%, 60%, 80% { transform: translate(1px, -1px); }
}

#effect-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 200;
    opacity: 0;
}
#effect-overlay.flash {
    animation: flash-animation 0.4s ease-out;
}
@keyframes flash-animation {
    0% { opacity: 0.7; }
    100% { opacity: 0; }
}


#test-mode-indicator {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: #d90429;
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 2.5cqi;
    z-index: 100;
    display: none; /* È†êË®≠Èö±Ëóè */
}

/* --- ‰∏äÂçäÈÉ® - Ë≥áË®äÈù¢Êùø --- */
.info-panel {
    height: 55%; /* Adjusted layout */
    display: flex;
    flex-direction: column;
    min-height: 0;
}

/* --- ‰∏ãÂçäÈÉ® - Áé©Ê≥ïÈù¢Êùø --- */
.gameplay-panel {
    height: 45%; /* Adjusted layout */
    display: flex;
    flex-direction: column;
    min-height: 0;
}

/* --- È†ÇÈÉ®Êà∞È¨•Â†¥ÊôØ --- */
.battle-scene {
    flex-grow: 1;
    flex-shrink: 1;
    min-height: 0;
    position: relative;
    background-color: #2a2a3e;
    padding: 10px;
    display: flex;
    justify-content: space-between;
    border-bottom: 2px solid #0f3460;
}

#attack-ray {
    position: absolute;
    display: block;
    width: 4px;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0.1), #fca311, rgba(255, 255, 255, 0.1));
    box-shadow: 0 0 8px #fca311;
    opacity: 0;
    transition: opacity 0.1s;
    pointer-events: none;
    z-index: 14;
    transform-origin: top center;
    border-radius: 2px;
}

.score-display {
    color: #ffffff;
    font-size: 4.5cqi;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    white-space: nowrap;
    width: fit-content;
    margin: 0 auto; /* Center horizontally */
    padding: 5px 0; /* Add vertical spacing */
    flex-shrink: 0; /* Prevent shrinking */
}

.score-display .score-item {
    display: flex;
    align-items: center;
}

.score-display .score-item:not(:first-child)::before {
    content: '|';
    margin: 0 8px;
    color: #f9d923;
    opacity: 0.5;
}

.team {
    width: 45%;
    position: relative;
}

.character-slot {
    position: absolute;
    width: 13cqi;
    text-align: center;
    transition: transform 0.2s ease-out, filter 0.3s;
}

.player-team .character-slot.attacking-forward {
    transform: translateX(4cqi);
    z-index: 15;
}
.enemy-team .character-slot.attacking-forward {
    transform: translateX(-4cqi);
    z-index: 15;
}


.player-team .character-slot .char-icon.ultimate-ready {
    cursor: pointer;
    animation: ultimate-ready-glow 1.5s infinite alternate;
}

@keyframes ultimate-ready-glow {
    from { box-shadow: 0 0 8px 2px #fff; }
    to { box-shadow: 0 0 10px 8px #fca311; }
}

.char-icon {
    width: 12cqi;
    height: 12cqi;
    border-radius: 10px;
    margin: 0 auto 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 5cqi;
    font-weight: bold;
    color: white;
    border: 2px solid #fff;
    position: relative;
}

.rank-icon {
    position: absolute;
    top: -1.5cqi;
    left: -1.5cqi;
    width: 4cqi;
    height: 4cqi;
    font-size: 3cqi;
    background-color: #1a1a2e;
    border-radius: 10%;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #fff;
    z-index: 5;
}

.enemy-intent-icon {
    position: absolute;
    top: -2cqi;
    left: 50%;
    transform: translateX(-50%);
    width: 5cqi;
    height: 5cqi;
    font-size: 4cqi;
    background-color: rgba(0,0,0,0.7);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    animation: intent-appear 0.5s ease-out;
}
@keyframes intent-appear {
    from { opacity: 0; transform: translateX(-50%) translateY(10px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

.boss-mechanic-display {
    position: absolute;
    bottom: -3cqi;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0,0,0,0.7);
    color: #fff;
    padding: 2px 8px;
    border-radius: 5px;
    font-size: 2.5cqi;
    display: flex;
    align-items: center;
    gap: 4px;
    z-index: 10;
}


.status-bar {
    height: 1cqi;
    border-radius: 4px;
    margin-bottom: 3px;
    background-color: #111;
    overflow: hidden; /* Ensure inner bars are clipped */
}

.status-bar > div {
    height: 100%;
    border-radius: 4px;
}

.hp-bar { background-color: #e94560; transition: width 0.3s ease; }
.mp-bar { background-color: #1e90ff; transition: width 0.3s ease; }

.char-icon.damaged {
    animation: damage-flash 0.3s ease-in-out;
}

@keyframes damage-flash {
    0%, 100% { box-shadow: none; }
    50% { box-shadow: 0 0 15px 5px #ff0000; }
}

.char-icon.dead {
    filter: grayscale(100%);
    background-color: #555 !important;
}

.char-icon.attacking {
    animation: attack-pulse 0.5s ease-in-out;
}

.char-icon.casting-skill {
    animation: skill-cast-glow 0.6s ease-in-out;
}

@keyframes skill-cast-glow {
    0% { box-shadow: none; }
    50% { box-shadow: 0 0 20px 8px #ffff00; transform: scale(1.2); }
    100% { box-shadow: none; transform: scale(1); }
}


@keyframes attack-pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.15); box-shadow: 0 0 15px 5px #fca311; }
    100% { transform: scale(1); }
}

.character-slot.frozen {
    filter: brightness(0.7);
}

.status-effects {
    position: absolute;
    bottom: 2.5cqi;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 4px;
    height: 4cqi;
    z-index: 10;
    pointer-events: none;
}
.effect-icon {
    width: 4cqi;
    height: 4cqi;
    background-color: rgba(0,0,0,0.6);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 3cqi;
    color: white;
    text-shadow: 1px 1px 2px black;
    animation: status-appear 0.3s ease-out;
}
@keyframes status-appear {
    from { transform: scale(0) rotate(-90deg); opacity: 0; }
    to { transform: scale(1) rotate(0deg); opacity: 1; }
}


/* Player team positions */
[data-id="C"] { top: 2%; left: 5%; }
[data-id="D"] { top: 35%; left: 5%; }
[data-id="E"] { top: 68%; left: 5%; }
[data-id="A"] { top: 18%; left: 40%; }
[data-id="B"] { top: 51%; left: 40%; }

/* Enemy team positions */
[data-id="c"] { top: 2%; right: 5%; }
[data-id="d"] { top: 35%; right: 5%; }
[data-id="e"] { top: 68%; right: 5%; }
[data-id="a"] { top: 18%; right: 40%; }
[data-id="b"] { top: 51%; right: 40%; }

.countdown-bar {
    flex-shrink: 0;
    padding: 8px;
    background-color: #162447;
    text-align: center;
    font-size: 2.8cqi;
    color: #fca311;
    border-bottom: 2px solid #0f3460;
    position: relative;
    transition: box-shadow 0.3s;
}

.countdown-bar.urgent {
    animation: pulse-red 1s infinite alternate;
    border-radius: 5px; /* for box-shadow */
}
@keyframes pulse-red {
    from { box-shadow: 0 0 4px #e94560; }
    to { box-shadow: 0 0 16px 4px #e94560; }
}

#timer-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 5px;
    background: linear-gradient(90deg, #e94560, #f9d923);
    width: 100%;
    transition: width 1s linear;
}

.props-bar {
    flex-shrink: 0;
    display: flex;
    justify-content: space-around;
    padding: 10px 5px;
    background-color: #10101a;
}

.prop-slot {
    width: 10cqi;
    height: 10cqi;
    background-color: #4a4a5e;
    border-radius: 8px;
    border: 2px solid #6a6a7e;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.board-container {
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 5px;
    min-height: 0;
    position: relative;
}

#combo-display {
    position: absolute;
    top: 5%;
    left: 50%;
    transform: translateX(-50%);
    font-size: 8cqi;
    font-weight: bold;
    color: #ffc300;
    text-shadow: 3px 3px 5px #000;
    opacity: 0;
    pointer-events: none;
    z-index: 50;
    transition: opacity 0.2s;
}

#combo-display.show {
    opacity: 1;
    animation: combo-pop 0.5s ease-out;
}

@keyframes combo-pop {
    0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
    70% { transform: translateX(-50%) scale(1.2); opacity: 1; }
    100% { transform: translateX(-50%) scale(1); opacity: 1; }
}

#game-board {
    width: 100%;
    aspect-ratio: 1 / 1;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 2px;
    background-color: #0a192f; /* Darker navy blue */
    --dark-square: #0a192f;
    --light-square: #0f2444;
    background-image: repeating-conic-gradient(from 45deg, var(--dark-square) 0% 25%, var(--light-square) 25% 50%);
    background-size: 25% 25%; /* 25% = 100/(8/2), 25% = 100/(8/2) */
    border: 3px solid #1f4068;
    border-radius: 10px;
    padding: 2px;
    transform: scale(1.02); /* Saved UI adjustment */
}

.rune {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    box-shadow: inset 0 -4px 6px rgba(0,0,0,0.3); /* Slightly increased shadow */
}

.rune.dropping {
    animation: drop-animation 0.5s cubic-bezier(0.42, 0, 1, 1) forwards;
}

@keyframes drop-animation {
    from {
        transform: translateY(var(--start-y));
        opacity: 0;
    }
    60% {
        opacity: 1;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.rune.selected {
    transform: scale(1.1);
    box-shadow: 0 0 10px 3px #ffffff, inset 0 -4px 6px rgba(0,0,0,0.3);
    border: 2px solid white;
}

/* Saved UI Colors */
.rune-0 { background: radial-gradient(circle, #ff8a8a, #d90429); } /* Red */
.rune-1 { background: radial-gradient(circle, #8ad8ff, #0077b6); } /* Blue */
.rune-2 { background: radial-gradient(circle, #8aff99, #2d9d43); } /* Green */
.rune-3 { background: radial-gradient(circle, #fff78a, #fca311); } /* Yellow */
.rune-4 { background: radial-gradient(circle, #e8a2ff, #9d4edd); } /* Purple */

.rune .special-icon {
    width: 80%;
    height: 80%;
    filter: drop-shadow(0 0 3px rgba(255,255,255,0.7));
    z-index: 1;
}

.rune-status-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 5.5cqi;
    font-weight: bold;
    color: white;
    opacity: 0.9;
    pointer-events: none;
    z-index: 3;
    text-shadow: 0 0 5px black, 0 0 5px black, 0 0 5px black;
}

.rune-debug-info {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.2cqi;
    color: white;
    font-weight: bold;
    text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black;
    pointer-events: none;
    z-index: 2;
    display: none; /* È†êË®≠Èö±Ëóè */
}

.game-wrapper.test-mode-on .rune-debug-info {
    display: flex; /* Ê∏¨Ë©¶Ê®°Âºè‰∏ãÈ°ØÁ§∫ */
}

.matched {
    animation: disappear 0.5s forwards;
}

@keyframes disappear {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0); opacity: 0; }
}

.rune.frozen {
    cursor: not-allowed;
    pointer-events: none;
    box-shadow: inset 0 0 10px 4px #a2d2ff;
    border: 2px solid #bde0fe;
}

.rune .fog-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #383848;
    border-radius: 50%;
    z-index: 4;
    pointer-events: none;
    transition: opacity 0.5s ease-out;
}


.floating-text {
    position: absolute;
    top: 40%;
    left: 50%;
    color: white;
    font-size: 4cqi;
    font-weight: bold;
    text-shadow: 2px 2px 4px black;
    pointer-events: none;
    animation: float-up-fade-out 1.5s forwards;
    z-index: 100;
}

.floating-text.level-up, .floating-text.wave-start {
    color: #ffd700;
    font-size: 7cqi;
    animation: float-up-fade-out 2s forwards;
}

@keyframes float-up-fade-out {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -200%) scale(1.2); }
}

.floating-damage-text {
    position: absolute;
    font-size: 3.5cqi;
    font-weight: bold;
    text-shadow: 1px 1px 2px black;
    pointer-events: none;
    animation: float-up-damage 1.2s forwards ease-out;
    z-index: 101; /* Above floating skill text */
}

@keyframes float-up-damage {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
}

.floating-damage-text.player-damage { color: #ff4d4d; }
.floating-damage-text.enemy-damage { color: #ffffff; }
.floating-damage-text.heal { color: #70e000; }
.floating-damage-text.combo { color: #ffc300; font-style: italic; }

/* Game Over Screen */
.modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 300;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.modal-overlay.show {
    opacity: 1;
    pointer-events: auto;
}

.modal-content {
    background: linear-gradient(145deg, #1f4068, #162447);
    padding: 30px;
    border-radius: 20px;
    text-align: center;
    width: 80%;
    border: 2px solid #fca311;
    transform: scale(0.5);
    transition: transform 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
}

.modal-overlay.show .modal-content {
    transform: scale(1);
}

.modal-content h2 {
    font-size: 6cqi;
    color: #f9d923;
    margin-bottom: 15px;
    text-shadow: 2px 2px 4px #000;
}

.modal-content p {
    font-size: 3.5cqi;
    margin: 10px 0;
}

.modal-content button {
    margin-top: 20px;
    padding: 10px 30px;
    font-size: 3.5cqi;
    background-color: #fca311;
    color: #10101a;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.3s;
}

.modal-content button:hover {
    background-color: #ffc300;
}

/* Test Mode UI Settings Panel Styles */
#test-mode-ui-settings {
    display: none; /* Hidden by default */
    position: absolute;
    top: 50px;
    right: 10px;
    background-color: rgba(40, 40, 55, 0.9);
    border: 1px solid #fca311;
    border-radius: 8px;
    z-index: 500;
    color: #e0e0e0;
    font-size: 2.5cqi;
    width: 45cqi;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    backdrop-filter: blur(5px);
}
.game-wrapper.test-mode-on #test-mode-ui-settings {
    display: block; /* Shown in test mode */
}
.settings-header {
    background-color: #1f4068;
    padding: 8px;
    cursor: move;
    border-top-left-radius: 7px;
    border-top-right-radius: 7px;
    font-weight: bold;
    text-align: center;
}
.settings-content {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.settings-content fieldset {
    border: 1px solid #6a6a7e;
    border-radius: 5px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 5px;
}
.settings-content legend {
    color: #fca311;
    padding: 0 5px;
}
.settings-content label {
    font-weight: bold;
}
.settings-content select, .settings-content input, .settings-content button {
    width: 100%;
    padding: 5px;
    border-radius: 4px;
    border: 1px solid #6a6a7e;
    background-color: #10101a;
    color: #e0e0e0;
    font-size: 2.5cqi;
}
.settings-content button {
    cursor: pointer;
    background-color: #fca311;
    color: #10101a;
    font-weight: bold;
    margin-top: 5px;
}
.settings-content button:hover {
    background-color: #ffc300;
}
.settings-content input[type="color"] {
    height: 6cqi;
    padding: 2px;
}
</style>
<script type="importmap">
{
  "imports": {
    "marked": "https://aistudiocdn.com/marked@^16.2.1",
    "lit/": "https://aistudiocdn.com/lit@^3.3.1/",
    "lit": "https://aistudiocdn.com/lit@^3.3.1",
    "highlight.js": "https://aistudiocdn.com/highlight.js@^11.11.1",
    "marked-highlight": "https://aistudiocdn.com/marked-highlight@^2.2.2"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
<div class="game-wrapper">
    <div id="test-mode-indicator">[Ê∏¨Ë©¶Ê®°Âºè]</div>
    <div id="effect-overlay"></div>
    <div class="info-panel">
        <div class="battle-scene" id="battle-scene">
            <div id="attack-ray"></div>
            <div class="team player-team">
                <div class="character-slot" data-id="C"><div class="char-icon" style="background-color: #9d4edd;">C</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div><div class="status-bar"><div class="mp-bar" style="width: 0%;"></div></div></div>
                <div class="character-slot" data-id="D"><div class="char-icon" style="background-color: #2d9d43;">D</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div><div class="status-bar"><div class="mp-bar" style="width: 0%;"></div></div></div>
                <div class="character-slot" data-id="E"><div class="char-icon" style="background-color: #fca311;">E</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div><div class="status-bar"><div class="mp-bar" style="width: 0%;"></div></div></div>
                <div class="character-slot" data-id="A"><div class="char-icon" style="background-color: #d90429;">A</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div><div class="status-bar"><div class="mp-bar" style="width: 0%;"></div></div></div>
                <div class="character-slot" data-id="B"><div class="char-icon" style="background-color: #0077b6;">B</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div><div class="status-bar"><div class="mp-bar" style="width: 0%;"></div></div></div>
            </div>
            <div class="team enemy-team">
                <div class="character-slot" data-id="c"><div class="char-icon" style="background-color: #9d4edd;">c</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div></div>
                <div class="character-slot" data-id="d"><div class="char-icon" style="background-color: #2d9d43;">d</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div></div>
                <div class="character-slot" data-id="e"><div class="char-icon" style="background-color: #fca311;">e</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div></div>
                <div class="character-slot" data-id="a"><div class="char-icon" style="background-color: #d90429;">a</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div></div>
                <div class="character-slot" data-id="b"><div class="char-icon" style="background-color: #0077b6;">b</div><div class="status-bar"><div class="hp-bar" style="width: 100%;"></div></div></div>
            </div>
        </div>
        <div class="score-display" id="score-display-container">
            <!-- JS will render content here -->
        </div>
        <div class="countdown-bar">
            <span>ÂõûÂêàÂÄíÊï∏</span>
            <div id="timer-bar"></div>
        </div>
        <div class="props-bar">
            <div class="prop-slot"></div><div class="prop-slot"></div><div class="prop-slot"></div><div class="prop-slot"></div>
            <div class="prop-slot"></div><div class="prop-slot"></div><div class="prop-slot"></div><div class="prop-slot"></div>
        </div>
    </div>
    <div class="gameplay-panel">
        <div class="board-container">
            <div id="combo-display"></div>
            <div id="game-board"></div>
        </div>
    </div>
    <div id="game-over-screen" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title">ÈÅäÊà≤ÁµêÊùü</h2>
            <p>ÊúÄÈ´òÊ≥¢Ê¨°: <span id="final-wave">1</span></p>
            <p>ÊúÄÁµÇÂàÜÊï∏: <span id="final-score">0</span></p>
            <button id="restart-button">ÈáçÊñ∞ÈñãÂßã</button>
        </div>
    </div>
    <!-- Test Mode UI Settings Panel -->
    <div id="test-mode-ui-settings">
        <div class="settings-header">UI Settings (Drag Me)</div>
        <div class="settings-content">
            <fieldset>
                <legend>Transform</legend>
                <label for="ui-element-selector">Element:</label>
                <select id="ui-element-selector"></select>
                <label for="scale-slider">Zoom:</label>
                <input type="range" id="scale-slider" min="0.5" max="2" step="0.05" value="1">
                <label for="pos-x-slider">Move X:</label>
                <input type="range" id="pos-x-slider" min="-200" max="200" step="1" value="0">
                <label for="pos-y-slider">Move Y:</label>
                <input type="range" id="pos-y-slider" min="-200" max="200" step="1" value="0">
                <button id="reset-transform-button">Reset Transform</button>
            </fieldset>
            <fieldset>
                <legend>Colors</legend>
                <label for="color-element-selector">Element:</label>
                <select id="color-element-selector"></select>
                <label for="color-picker">Color:</label>
                <input type="color" id="color-picker" value="#ff0000">
                <button id="reset-colors-button">Reset All Colors</button>
            </fieldset>
        </div>
    </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Èü≥ÊïàÁÆ°ÁêÜÂô® ---
    const AudioManager = {
        audioCtx: null,
        initialize() {
            if (!this.audioCtx) {
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser");
                }
            }
        },
        playSound({ type = 'sine', frequency = 440, duration = 0.1, volume = 0.5, attack = 0.01, decay = 0.05 }) {
            if (!this.audioCtx) return;
            const oscillator = this.audioCtx.createOscillator();
            const gainNode = this.audioCtx.createGain();
            const now = this.audioCtx.currentTime;
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, now);
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + attack);
            gainNode.gain.linearRampToValueAtTime(0, now + duration - decay);
            oscillator.connect(gainNode);
            gainNode.connect(this.audioCtx.destination);
            oscillator.start(now);
            oscillator.stop(now + duration);
        },
        playSelect() { this.playSound({ frequency: 600, duration: 0.1, volume: 0.3, type: 'triangle' }); },
        playSwap() {
            this.playSound({ frequency: 440, duration: 0.15, volume: 0.4, type: 'square' });
            setTimeout(() => this.playSound({ frequency: 550, duration: 0.1, volume: 0.4, type: 'square' }), 50);
        },
        playMatch(combo = 1) {
            const baseFreq = 800;
            this.playSound({ frequency: baseFreq * Math.pow(1.05, combo), duration: 0.15, volume: 0.5, type: 'triangle', decay: 0.1 });
        },
        playSpecial() {
            this.playSound({ type: 'triangle', frequency: 1000, duration: 0.4, volume: 0.7, decay: 0.2 });
            setTimeout(() => this.playSound({ type: 'triangle', frequency: 1200, duration: 0.3, volume: 0.6, decay: 0.15 }), 100);
        },
        playUltimate() {
            this.playSound({ frequency: 1200, duration: 0.6, volume: 0.8, type: 'sawtooth', decay: 0.4 });
            setTimeout(() => this.playSound({ frequency: 1500, duration: 0.4, volume: 0.7, type: 'sawtooth', decay: 0.3 }), 150);
        },
        playAttack() { this.playSound({ type: 'square', frequency: 300, duration: 0.2, volume: 0.6, decay: 0.1 }); },
        playDamage() { this.playSound({ type: 'sawtooth', frequency: 200, duration: 0.3, volume: 0.8, decay: 0.2 }); },
        playHit() { this.playSound({ type: 'sine', frequency: 1200, duration: 0.15, volume: 0.4, attack: 0.005, decay: 0.1 }); },
        playHeal() { this.playSound({type: 'sine', frequency: 659, duration: 0.5, volume: 0.6, decay: 0.4}); },
        playDebuff() { this.playSound({type: 'square', frequency: 150, duration: 0.5, volume: 0.5, decay: 0.4}); },
        playBurn() { this.playSound({type: 'sawtooth', frequency: 100, duration: 0.2, volume: 0.4, decay: 0.15}); },
        playLevelUp() {
            this.playSound({ type: 'sine', frequency: 523, duration: 0.2, volume: 0.6});
            setTimeout(() => this.playSound({ type: 'sine', frequency: 784, duration: 0.2, volume: 0.6}), 150);
            setTimeout(() => this.playSound({ type: 'sine', frequency: 1046, duration: 0.4, volume: 0.7}), 300);
        },
        playGameOver() { this.playSound({ type: 'sawtooth', frequency: 220, duration: 1, volume: 0.8, decay: 0.8 }); },
        playVictory() {
            this.playSound({ type: 'sine', frequency: 523, duration: 0.2, volume: 0.6});
            setTimeout(() => this.playSound({ type: 'sine', frequency: 659, duration: 0.2, volume: 0.6}), 200);
            setTimeout(() => this.playSound({ type: 'sine', frequency: 784, duration: 0.4, volume: 0.7}), 400);
        },
        playTick() { this.playSound({ type: 'sine', frequency: 1200, duration: 0.05, volume: 0.1, attack: 0.005, decay: 0.01 }); },
    };

    // --- ÈÅäÊà≤Ë®≠ÂÆö ---
    const COLS = 8;
    const ROWS = 8;
    const RUNE_TYPES = 5;
    const ROUND_TIME = 10;
    const INITIAL_BASE_DAMAGE_PER_RUNE = 5;
    const INITIAL_ENEMY_BASE_DAMAGE = 10;
    let BASE_DAMAGE_PER_RUNE = INITIAL_BASE_DAMAGE_PER_RUNE;
    let ENEMY_BASE_DAMAGE = INITIAL_ENEMY_BASE_DAMAGE;
    let BURNING_DAMAGE = 5;
    const XP_PER_RUNE = 2;
    const MP_PER_RUNE = 8;
    const COMBO_DAMAGE_BONUS = 0.2; // 20% bonus per combo level

    // --- Á¨¶ÊñáÈ°ûÂûãÂÆöÁæ© ---
    const RUNE_NORMAL = 'normal';
    const RUNE_STRIPED_H = 'striped_h';
    const RUNE_STRIPED_V = 'striped_v';
    const RUNE_BOMB = 'bomb';
    const RUNE_COLOR_BOMB = 'color_bomb';

    // --- ÈÅäÊà≤ËÆäÊï∏ ---
    let board = [];
    let selectedRune = null;
    let score = 0;
    let isSwapping = false;
    let isExecutingUltimate = false;
    let roundTimer;
    let countdownInterval;
    let playerTurnTimerStarted = false;
    let players = [];
    let enemies = [];
    let logCounter = 1;
    let comboCounter = 0;
    let frozenRuneColor = null;
    let playerLevel = 1;
    let playerXP = 0;
    let xpToNextLevel = 100;
    let currentWave = 1;
    let gameTimeInSeconds = 0;
    let gameTimerInterval = null;

    // --- Ê∏¨Ë©¶Ê®°ÂºèËÆäÊï∏ ---
    let testModeActive = false;
    let lastTKeyPressTime = 0;
    let lastClickedRunePos = { r: null, c: null };

    // --- DOM ÂÖÉÁ¥† ---
    const gameBoardElement = document.getElementById('game-board');
    const scoreDisplayContainer = document.getElementById('score-display-container');
    const timerBarElement = document.getElementById('timer-bar');
    const testModeIndicator = document.getElementById('test-mode-indicator');
    const gameWrapper = document.querySelector('.game-wrapper');
    const battleSceneElement = document.getElementById('battle-scene');
    const effectOverlay = document.getElementById('effect-overlay');
    const comboDisplayElement = document.getElementById('combo-display');
    const gameOverScreenElement = document.getElementById('game-over-screen');

    // --- Êó•Ë™åÁ≥ªÁµ± ---
    function logStep(message) {
        console.log(`[${logCounter++}] ${message}`);
    }
    
    // --- TEST MODE UI SETTINGS ---
    const uiSettingsPanel = document.getElementById('test-mode-ui-settings');
    let uiSettingsState = {};
    let customColorStyleElement = null;

    function setupTestModeUI() {
        if (!uiSettingsPanel) return;

        // --- Draggable Panel Logic ---
        const header = uiSettingsPanel.querySelector('.settings-header');
        let isDragging = false;
        let offsetX, offsetY;

        header.addEventListener('pointerdown', (e) => {
            isDragging = true;
            offsetX = e.clientX - uiSettingsPanel.offsetLeft;
            offsetY = e.clientY - uiSettingsPanel.offsetTop;
            uiSettingsPanel.style.cursor = 'grabbing';
            header.style.cursor = 'grabbing';
            e.preventDefault();
        });

        document.addEventListener('pointermove', (e) => {
            if (!isDragging) return;
            uiSettingsPanel.style.left = `${e.clientX - offsetX}px`;
            uiSettingsPanel.style.top = `${e.clientY - offsetY}px`;
        });

        document.addEventListener('pointerup', () => {
            isDragging = false;
            uiSettingsPanel.style.cursor = 'default';
            header.style.cursor = 'move';
        });

        // --- Target Definitions ---
        const uiTransformTargets = {
            'Info Panel': document.querySelector('.info-panel'),
            'Gameplay Panel': document.querySelector('.gameplay-panel'),
            'Battle Scene': document.getElementById('battle-scene'),
            'Score Display': document.querySelector('.score-display'),
            'Game Board': document.getElementById('game-board'),
        };

        const uiColorTargets = {
            'Game Background': { selector: '.game-wrapper', property: 'background-color' },
            'Board Background': { selector: '#game-board', property: 'background-color' },
            'Rune Red': { selector: '.rune-0', property: 'background' },
            'Rune Blue': { selector: '.rune-1', property: 'background' },
            'Rune Green': { selector: '.rune-2', property: 'background' },
            'Rune Yellow': { selector: '.rune-3', property: 'background' },
            'Rune Purple': { selector: '.rune-4', property: 'background' },
            'Player A': { selector: '.player-team [data-id="A"] .char-icon', property: 'background-color' },
            'Player B': { selector: '.player-team [data-id="B"] .char-icon', property: 'background-color' },
            'Player C': { selector: '.player-team [data-id="C"] .char-icon', property: 'background-color' },
            'Player D': { selector: '.player-team [data-id="D"] .char-icon', property: 'background-color' },
            'Player E': { selector: '.player-team [data-id="E"] .char-icon', property: 'background-color' },
        };

        // --- DOM Element References ---
        const transformSelector = document.getElementById('ui-element-selector');
        const scaleSlider = document.getElementById('scale-slider');
        const posXSlider = document.getElementById('pos-x-slider');
        const posYSlider = document.getElementById('pos-y-slider');
        const resetTransformBtn = document.getElementById('reset-transform-button');

        const colorSelector = document.getElementById('color-element-selector');
        const colorPicker = document.getElementById('color-picker');
        const resetColorsBtn = document.getElementById('reset-colors-button');

        // --- State Initialization & Population ---
        Object.keys(uiTransformTargets).forEach(key => {
            const target = uiTransformTargets[key];
            uiSettingsState[key] = {
                scale: 1, x: 0, y: 0,
                // Store the initial transform so we can reset to it
                initialTransform: target ? target.style.transform : ''
            };
            const option = document.createElement('option');
            option.value = key;
            option.textContent = key;
            transformSelector.appendChild(option);
        });

        Object.keys(uiColorTargets).forEach(key => {
            uiSettingsState[key] = { color: null, initial: null };
            const option = document.createElement('option');
            option.value = key;
            option.textContent = key;
            colorSelector.appendChild(option);
        });
        
        customColorStyleElement = document.createElement('style');
        customColorStyleElement.id = 'custom-colors-style';
        document.head.appendChild(customColorStyleElement);

        // --- Functions ---
        function applyTransforms(key) {
            const target = uiTransformTargets[key];
            const state = uiSettingsState[key];
            if (target && state) {
                // Combine initial transform with slider adjustments
                const newTransform = `${state.initialTransform} translateX(${state.x}px) translateY(${state.y}px) scale(${state.scale})`;
                target.style.transform = newTransform.trim();
                target.style.transformOrigin = 'center center';
                target.style.zIndex = state.scale !== 1 || state.x !== 0 || state.y !== 0 ? 10 : 'auto';
            }
        }
        
        function updateTransformSliders(key) {
            const state = uiSettingsState[key];
            if (state) {
                scaleSlider.value = state.scale;
                posXSlider.value = state.x;
                posYSlider.value = state.y;
            }
        }

        function updateColorOverrides() {
            let cssRules = '';
            Object.keys(uiColorTargets).forEach(key => {
                const state = uiSettingsState[key];
                const target = uiColorTargets[key];
                if (state.color) {
                    cssRules += `${target.selector} { ${target.property}: ${state.color} !important; }\n`;
                }
            });
            customColorStyleElement.textContent = cssRules;
            renderBoard(false);
        }

        function colorToHex(color) {
            if (!color || color === 'none' || color.includes('gradient')) {
                const match = color ? color.match(/rgba?\((\d+,\s*\d+,\s*\d+)/) : null;
                if (match) {
                    const rgb = `rgb(${match[1]})`;
                    const temp = document.createElement("div");
                    temp.style.color = rgb;
                    document.body.appendChild(temp);
                    const computedColor = window.getComputedStyle(temp).color;
                    document.body.removeChild(temp);
                    const rgbParts = computedColor.match(/\d+/g).map(Number);
                    return '#' + rgbParts.slice(0, 3).map(x => ('0' + x.toString(16)).slice(-2)).join('');
                }
                return '#000000';
            }
            const temp = document.createElement("div");
            temp.style.color = color;
            document.body.appendChild(temp);
            const computedColor = window.getComputedStyle(temp).color;
            document.body.removeChild(temp);
            const rgb = computedColor.match(/\d+/g).map(Number);
            return '#' + rgb.slice(0, 3).map(x => ('0' + x.toString(16)).slice(-2)).join('');
        }

        function updateColorPicker(key) {
            const state = uiSettingsState[key];
            const target = uiColorTargets[key];
            if (!state || !target) return;

            let currentColorToConvert = state.color;
            if (!currentColorToConvert) {
                if (!state.initial) {
                    const element = document.querySelector(target.selector);
                    if (element) {
                        state.initial = window.getComputedStyle(element).getPropertyValue(target.property);
                    }
                }
                currentColorToConvert = state.initial;
            }
            colorPicker.value = colorToHex(currentColorToConvert);
        }

        // --- Event Listeners ---
        transformSelector.addEventListener('change', (e) => updateTransformSliders(e.target.value));
        scaleSlider.addEventListener('input', (e) => {
            const key = transformSelector.value;
            uiSettingsState[key].scale = e.target.value;
            applyTransforms(key);
        });
        posXSlider.addEventListener('input', (e) => {
            const key = transformSelector.value;
            uiSettingsState[key].x = e.target.value;
            applyTransforms(key);
        });
        posYSlider.addEventListener('input', (e) => {
            const key = transformSelector.value;
            uiSettingsState[key].y = e.target.value;
            applyTransforms(key);
        });
        resetTransformBtn.addEventListener('click', () => {
            const key = transformSelector.value;
            const state = uiSettingsState[key];
            if (state) {
                state.scale = 1;
                state.x = 0;
                state.y = 0;
                applyTransforms(key);
                updateTransformSliders(key);
            }
        });
        colorSelector.addEventListener('change', (e) => updateColorPicker(e.target.value));
        colorPicker.addEventListener('input', (e) => {
            const key = colorSelector.value;
            uiSettingsState[key].color = e.target.value;
            updateColorOverrides();
        });
        resetColorsBtn.addEventListener('click', () => {
            Object.keys(uiColorTargets).forEach(key => {
                uiSettingsState[key].color = null;
            });
            updateColorOverrides();
            updateColorPicker(colorSelector.value);
        });
        
        updateTransformSliders(transformSelector.value);
        updateColorPicker(colorSelector.value);
    }


    // --- ÈÅäÊà≤ÂàùÂßãÂåñ ---
    function initializeGame() {
        logStep("ÈÅäÊà≤ÂàùÂßãÂåñÈñãÂßã...");
        initializeCharacters();
        initializeBoard();
        updateAllCharacterUI();
        prepareNextPlayerTurn();
        setupEventListeners();
        setupTestModeUI();
        
        gameTimeInSeconds = 0;
        updatePlayerUI();
        clearInterval(gameTimerInterval);
        gameTimerInterval = setInterval(() => {
            gameTimeInSeconds++;
            // This timer is now independent of UI updates
        }, 1000);

        logStep("ÈÅäÊà≤ÂàùÂßãÂåñÂÆåÊàê!");
    }

    // --- ËßíËâ≤Êï∏ÊìöÂàùÂßãÂåñ ---
    function initializeCharacters() {
        const characterSlots = document.querySelectorAll('.character-slot');
        players = [];
        enemies = [];

        const PLAYER_SKILLS = {
            'A': { name: 'ÈáçÊìä', execute: playerSkillSingleTarget, ultimate: {name: 'ÁÖâÁçÑÁÅ´Êµ∑', execute: playerUltimate_FieryRage} },
            'B': { name: 'Ê∞¥‰πãÊ≤ªÁôí', execute: playerSkillHealLowest, ultimate: {name: 'ÁµïÂ∞çÈõ∂Â∫¶', execute: playerUltimate_FreezeAll} },
            'C': { name: 'ÊöóÂΩ±Á©øÂà∫', execute: playerSkillAoeDamage, ultimate: {name: 'ÊöóÂΩ±Â•áË•≤', execute: playerUltimate_ExecuteLowest} },
            'D': { name: 'Ëó§ËîìÈû≠Á¨û', execute: playerSkillSingleTargetDebuff, ultimate: {name: 'Ëá™ÁÑ∂Á•ùÁ¶è', execute: playerUltimate_CleanseAndHeal} },
            'E': { name: 'Á•ûËÅñ‰πãÂÖâ', execute: playerSkillAoeHeal, ultimate: {name: 'Èõ∑Á•û‰πãÊÄí', execute: playerUltimate_CreateBombs} }
        };
        const ENEMY_SKILLS = {
            'a': { name: 'ÁÅ´ÁÑ∞È¢®Êö¥', icon: 'üî•', execute: enemyCastFire },
            'b': { name: 'Áæ§È´îÊâìÊìä', icon: 'üí•', execute: enemyCastGroupAttack },
            'c': { name: 'ÂÜ∞ÂáçË°ì', icon: 'üßä', execute: enemyCastFreeze },
            'd': { name: 'Êà∞Áà≠Ëø∑Èúß', icon: 'üå´Ô∏è', execute: enemyCastFogOfWar },
            'e': { name: 'Á¨¶ÊñáËÖêÂåñ', icon: '‚ò£Ô∏è', execute: enemyCastRuneCorruption }
        };

        characterSlots.forEach(slot => {
            const id = slot.dataset.id;
            const isPlayer = id === id.toUpperCase();
            const characterData = {
                id: id, hp: 100, maxHp: 100, baseMaxHp: 100,
                mp: 0, maxMp: 100,
                element: slot,
                status: {},
                rank: 'normal',
                colorIndex: isPlayer ? 'ABDEC'.indexOf(id) : 'abdec'.indexOf(id.toLowerCase()),
                skill: isPlayer ? PLAYER_SKILLS[id] : ENEMY_SKILLS[id]
            };
            if (isPlayer) {
                players.push(characterData);
            } else {
                characterData.skillCooldown = Math.floor(Math.random() * 2) + 1;
                enemies.push(characterData);
            }
        });
        updateAllCharacterUI();
    }

    function updateAllCharacterUI() {
        [...players, ...enemies].forEach(char => updateCharacterUI(char.id));
        updatePlayerUI();
    }

    function updateCharacterUI(characterId) {
        const character = [...players, ...enemies].find(c => c.id === characterId);
        if (!character || !character.element) return;
        
        const hpPercentage = (character.hp / character.maxHp) * 100;
        const hpBar = character.element.querySelector('.hp-bar');
        if (hpBar) hpBar.style.width = `${hpPercentage}%`;

        const icon = character.element.querySelector('.char-icon');
        if (icon) icon.classList.toggle('dead', character.hp <= 0);

        if (character.mp !== undefined) {
            const mpPercentage = (character.mp / character.maxMp) * 100;
            const mpBar = character.element.querySelector('.mp-bar');
            if (mpBar) mpBar.style.width = `${mpPercentage}%`;
            if (icon) icon.classList.toggle('ultimate-ready', character.mp >= character.maxMp);
        }

        // Rank icons
        let rankIcon = character.element.querySelector('.rank-icon');
        if (character.rank !== 'normal') {
            if (!rankIcon) {
                rankIcon = document.createElement('div');
                rankIcon.className = 'rank-icon';
                icon?.prepend(rankIcon);
            }
            rankIcon.textContent = character.rank === 'boss' ? 'üíÄ' : '‚≠ê';
        } else if (rankIcon) {
            rankIcon.remove();
        }

        // Boss mechanics display
        let bossMechanicDisplay = character.element.querySelector('.boss-mechanic-display');
        if (character.rank === 'boss' && character.shieldHp > 0) {
            if (!bossMechanicDisplay) {
                bossMechanicDisplay = document.createElement('div');
                bossMechanicDisplay.className = 'boss-mechanic-display';
                icon?.appendChild(bossMechanicDisplay);
            }
            bossMechanicDisplay.innerHTML = `<span class="rune-${character.shieldColor}" style="width: 2cqi; height: 2cqi; border-radius: 50%; display: inline-block;"></span> ${character.shieldHp}`;
        } else if (bossMechanicDisplay) {
            bossMechanicDisplay.remove();
        }
    }


    function updatePlayerUI() {
        if (!scoreDisplayContainer) return;
        scoreDisplayContainer.innerHTML = `
            <div class="score-item">Á≠âÁ∫ß: ${playerLevel}</div>
            <div class="score-item">ÂÖ≥Âç°: ${currentWave}</div>
            <div class="score-item">ÂàÜÊï∞: <span id="score">${Math.round(score)}</span></div>
        `;
    }

    // --- Ê£ãÁõ§ÂàùÂßãÂåñ ---
    function initializeBoard() {
        logStep("Ê≠£Âú®ÂàùÂßãÂåñÊ£ãÁõ§...");
        board = [];
        for (let r = 0; r < ROWS; r++) {
            board[r] = [];
            for (let c = 0; c < COLS; c++) {
                board[r][c] = { color: generateSafeColor(r, c), type: RUNE_NORMAL, status: {} };
            }
        }
        renderBoard(false);
        logStep("Ê£ãÁõ§Ê∏≤ÊüìÂÆåÊàê„ÄÇ");
    }

    function generateSafeColor(r, c, tempBoard = board) {
        let randomColor;
        const BANNED_COLORS = [];
        if (tempBoard[r]) {
            if (c >= 2 && tempBoard[r][c - 1]?.color === tempBoard[r][c - 2]?.color) {
                BANNED_COLORS.push(tempBoard[r][c - 1].color);
            }
        }
        if (r >= 2 && tempBoard[r - 1] && tempBoard[r - 2]) {
            if (tempBoard[r - 1][c]?.color === tempBoard[r - 2][c]?.color) {
                BANNED_COLORS.push(tempBoard[r - 1][c].color);
            }
        }
        do {
            randomColor = Math.floor(Math.random() * RUNE_TYPES);
        } while (BANNED_COLORS.includes(randomColor));
        return randomColor;
    }

    // --- ÂõûÂêàË®àÊôÇÂô® ---
    function startRoundTimer() {
        if (testModeActive || playerTurnTimerStarted) return;
        playerTurnTimerStarted = true;
        logStep("Áé©ÂÆ∂ÂõûÂêàË®àÊôÇÂô®ÂïüÂãï!");
        clearInterval(roundTimer);
        clearInterval(countdownInterval);

        if (timerBarElement) {
            timerBarElement.style.transition = 'none';
            timerBarElement.style.width = '100%';
            setTimeout(() => {
                if (timerBarElement) {
                    timerBarElement.style.transition = `width ${ROUND_TIME}s linear`;
                    timerBarElement.style.width = '0%';
                }
            }, 50);
        }
        roundTimer = setTimeout(enemyTurn, ROUND_TIME * 1000);
        
        countdownInterval = setInterval(() => { AudioManager.playTick(); }, 1000);
        setTimeout(() => clearInterval(countdownInterval), ROUND_TIME * 1000);

        setTimeout(() => {
            const countdownBar = document.querySelector('.countdown-bar');
            if (countdownBar && playerTurnTimerStarted) {
                countdownBar.classList.add('urgent');
            }
        }, (ROUND_TIME - 2) * 1000);
    }

    async function prepareNextPlayerTurn() {
        logStep("Ê∫ñÂÇôÁé©ÂÆ∂‰∏ã‰∏ÄÂõûÂêà...");
        isSwapping = false;
        playerTurnTimerStarted = false;
        clearInterval(roundTimer);
        clearInterval(countdownInterval);
        document.querySelector('.countdown-bar')?.classList.remove('urgent');

        if (timerBarElement) {
            timerBarElement.style.transition = 'none';
            timerBarElement.style.width = '100%';
        }
        
        renderEnemyIntents();
        await handleBoardStatusEffects();

        let needsRender = false;
        let hasFrozenRunes = false;
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const rune = board[r]?.[c];
                if (rune?.status) {
                    if (rune.status.frozen > 0) {
                        rune.status.frozen--;
                        needsRender = true;
                         if (rune.status.frozen > 0) hasFrozenRunes = true;
                    }
                    if (rune.status.fog > 0) {
                        rune.status.fog--;
                        needsRender = true;
                        if (rune.status.fog === 0) {
                            delete rune.status.fog;
                            logStep(`(${r},${c}) ÁöÑËø∑ÈúßÊ∂àÊï£‰∫Ü„ÄÇ`);
                        }
                    }
                }
            }
        }

        if (!hasFrozenRunes) {
            frozenRuneColor = null;
        }
        if (needsRender) {
            renderBoard(false);
        }
    }

    // --- Ê∏≤ÊüìÊ£ãÁõ§ ---
    function renderBoard(isAnimating = false) {
        if (!gameBoardElement) return;
        gameBoardElement.innerHTML = '';
        for (let r = 0; r < ROWS; r++) {
            if (!board[r]) continue;
            for (let c = 0; c < COLS; c++) {
                if (!board[r][c]) continue;
                const runeData = board[r][c];
                const rune = document.createElement('div');
                rune.dataset.row = r;
                rune.dataset.col = c;
                rune.dataset.id = `${r}-${c}`;

                rune.classList.add('rune');
                if (runeData.type === RUNE_COLOR_BOMB) {
                    rune.style.background = 'radial-gradient(circle, #ffffff, #d3d3d3)';
                } else {
                    rune.classList.add(`rune-${runeData.color}`);
                }
                
                if (runeData.burning) {
                    const statusText = document.createElement('div');
                    statusText.className = 'rune-status-text';
                    statusText.textContent = 'ÁÅ´';
                    rune.appendChild(statusText);
                }

                if (runeData.status) {
                    if (runeData.status.frozen > 0) {
                        rune.classList.add('frozen');
                        const statusText = document.createElement('div');
                        statusText.className = 'rune-status-text';
                        statusText.textContent = 'ÂÜ∞';
                        rune.appendChild(statusText);
                    }
                    if (runeData.status.corrupted) {
                         const statusText = document.createElement('div');
                         statusText.className = 'rune-status-text';
                         statusText.textContent = 'ÊØí';
                         rune.appendChild(statusText);
                    }
                    if (runeData.status.fog > 0) {
                        const fogOverlay = document.createElement('div');
                        fogOverlay.className = 'fog-overlay';
                        const opacity = 0.1 + (0.85 * (runeData.status.fog / 5));
                        fogOverlay.style.opacity = opacity;
                        rune.appendChild(fogOverlay);
                    }
                }

                if (!isAnimating) {
                    rune.addEventListener('pointerdown', onRunePointerDown);
                }

                const debugSpan = document.createElement('span');
                debugSpan.classList.add('rune-debug-info');
                let debugText = '';
                const colors = ['R', 'B', 'G', 'Y', 'P'];

                switch (runeData.type) {
                    case RUNE_NORMAL: debugText += `${colors[runeData.color]},${r},${c}`; break;
                    case RUNE_STRIPED_H: debugText += `1A,${colors[runeData.color]},${r},${c}`; break;
                    case RUNE_STRIPED_V: debugText += `1B,${colors[runeData.color]},${r},${c}`; break;
                    case RUNE_BOMB: debugText += `2,${colors[runeData.color]},${r},${c}`; break;
                    case RUNE_COLOR_BOMB: debugText += `3A,${r},${c}`; break;
                }
                debugSpan.textContent = debugText;
                rune.appendChild(debugSpan);

                if (runeData.type !== RUNE_NORMAL) {
                    const icon = document.createElement('img');
                    icon.classList.add('special-icon');
                    if (runeData.type === RUNE_BOMB) {
                        icon.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='-2 -2 28 28' fill='white'%3E%3Cpath d='M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z' stroke='black' stroke-width='1.5'/%3E%3C/svg%3E`;
                    } else if (runeData.type === RUNE_STRIPED_H) {
                        icon.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M3 11h18v2H3zM3 7h18v2H3zM3 15h18v2H3z' stroke='black' stroke-width='0.5'/%3E%3C/svg%3E`;
                    } else if (runeData.type === RUNE_STRIPED_V) {
                        icon.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M11 3h2v18h-2zM7 3h2v18H7zM15 3h2v18h-2z' stroke='black' stroke-width='0.5'/%3E%3C/svg%3E`;
                    } else if (runeData.type === RUNE_COLOR_BOMB) {
                        icon.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cdefs%3E%3CradialGradient id='grad'%3E%3Cstop offset='0%25' stop-color='%23ff0000'/%3E%3Cstop offset='20%25' stop-color='%23ff7f00'/%3E%3Cstop offset='40%25' stop-color='%23ffff00'/%3E%3Cstop offset='60%25' stop-color='%2300ff00'/%3E%3Cstop offset='80%25' stop-color='%230000ff'/%3E%3Cstop offset='100%25' stop-color='%238b00ff'/%3E%3C/radialGradient%3E%3C/defs%3E%3Ccircle cx='12' cy='12' r='10' fill='url(%23grad)' stroke='black' stroke-width='1.5'/%3E%3C/svg%3E`;
                    }
                    rune.appendChild(icon);
                }
                gameBoardElement.appendChild(rune);
            }
        }
    }

    // --- Áµ±‰∏ÄÁöÑÊåáÈáù‰∫ã‰ª∂ËôïÁêÜ ---
    function onRunePointerDown(event) {
        AudioManager.initialize();
        if (isSwapping || event.currentTarget.classList.contains('frozen') || event.currentTarget.classList.contains('corrupted') || board[event.currentTarget.dataset.row][event.currentTarget.dataset.col].status?.fog > 0) return;
        event.preventDefault();
        const target = event.currentTarget;
        const r = parseInt(target.dataset.row);
        const c = parseInt(target.dataset.col);
        lastClickedRunePos = { r, c };

        if (selectedRune) {
            document.querySelectorAll('.rune.selected').forEach(el => el.classList.remove('selected'));
            const r2 = selectedRune.r;
            const c2 = selectedRune.c;
            const isAdjacent = Math.abs(r - r2) + Math.abs(c - c2) === 1;
            selectedRune = null;
            if (isAdjacent && !(r === r2 && c === c2)) {
                swapRunes(r, c, r2, c2);
            }
        } else {
            AudioManager.playSelect();
            logStep(`ÈÅ∏Êìá/ÈñãÂßãÊãñÊãΩÁ¨¶ÊñáÊñº(${r},${c})`);
            selectedRune = { r, c };
            target.classList.add('selected');

            const onPointerMove = (moveEvent) => {
                const elem = document.elementFromPoint(moveEvent.clientX, moveEvent.clientY);
                if (elem && elem.classList.contains('rune') && !elem.classList.contains('frozen') && elem !== target) {
                    const moveR = parseInt(elem.dataset.row);
                    const moveC = parseInt(elem.dataset.col);
                    if (selectedRune) {
                        const isAdjacent = Math.abs(r - moveR) + Math.abs(c - moveC) === 1;
                        if (isAdjacent) {
                            cleanUpPointerListeners();
                            swapRunes(r, c, moveR, moveC);
                        }
                    }
                }
            };

            const onPointerUp = () => {
                cleanUpPointerListeners();
            };

            const cleanUpPointerListeners = () => {
                if (selectedRune && !target.classList.contains('selected')) {
                    selectedRune = null;
                }
                window.removeEventListener('pointermove', onPointerMove);
                window.removeEventListener('pointerup', onPointerUp);
            };
            
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
        }
    }

    // --- ‰∫§ÊèõÁ¨¶Êñá ---
    async function swapRunes(r1, c1, r2, c2) {
        if (isSwapping) return;
        AudioManager.playSwap();
        logStep(`ÂòóË©¶‰∫§Êèõ(${r1},${c1})Ëàá(${r2},${c2})`);
        isSwapping = true;
        selectedRune = null;
        document.querySelectorAll('.rune.selected').forEach(el => el.classList.remove('selected'));

        const rune1_before = board[r1]?.[c1];
        const rune2_before = board[r2]?.[c2];

        if (!rune1_before || !rune2_before) {
            isSwapping = false;
            return;
        }

        const isRune1Special = rune1_before.type !== RUNE_NORMAL;
        const isRune2Special = rune2_before.type !== RUNE_NORMAL;

        [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
        renderBoard(true);
        await sleep(200);
        
        let moveIsValid = false;

        if (isRune1Special && isRune2Special) {
            moveIsValid = true;
            startRoundTimer();
            await handleSpecialCombination(r1, c1, r2, c2, rune1_before, rune2_before);
        } else if (rune1_before.type === RUNE_COLOR_BOMB || rune2_before.type === RUNE_COLOR_BOMB) {
            moveIsValid = true;
            startRoundTimer();
            const colorBombPos = rune1_before.type === RUNE_COLOR_BOMB ? {r:r2, c:c2} : {r:r1, c:c1};
            const otherRuneColor = rune1_before.type === RUNE_COLOR_BOMB ? rune2_before.color : rune1_before.color;
            await handleColorBombActivation(colorBombPos, otherRuneColor);
        } else {
            let matchInfo = findMatchGroups();
            if (matchInfo.groups.length > 0) {
                moveIsValid = true;
                startRoundTimer();
                await handleMatchGroups(matchInfo, { r: r2, c: c2 });
            }
        }
        
        if (!moveIsValid) {
            logStep("ÁÑ°Êïà‰∫§Êèõ,ÊèõÂõûÂéü‰Ωç„ÄÇ");
            [board[r1][c1], board[r2][c2]] = [rune1_before, rune2_before];
            renderBoard(false);
            await sleep(200);
            isSwapping = false;
        } else {
            await cascadeMatches();
        }
    }
    
    async function cascadeMatches() {
        if (isSwapping && !playerTurnTimerStarted) isSwapping = false; // allow next cascade
        comboCounter++;
        if (comboCounter > 1) showComboText(comboCounter);
        let matchInfo = findMatchGroups();
        if (matchInfo.groups.length > 0) {
            logStep(`Ê™¢Ê∏¨Âà∞ÈÄ£ÈéñÂèçÊáâ! Combo: ${comboCounter}`);
            await handleMatchGroups(matchInfo, null);
            await cascadeMatches();
        } else {
            comboCounter = 0;
            hideComboText();
            isSwapping = false;
            if (playerTurnTimerStarted) {
                // Turn continues
            } else {
                 prepareNextPlayerTurn();
            }
        }
    }


    // --- Â∞ãÊâæÂåπÈÖçÁµÑ (Robust Version) ---
    function findMatchGroups(currentBoard = board) {
        const groups = [];
        const getRune = (r, c) => (r >= 0 && r < ROWS && c >= 0 && c < COLS && currentBoard[r]) ? currentBoard[r][c] : null;
    
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; ) {
                const startRune = getRune(r, c);
                if (!startRune || startRune.type === RUNE_COLOR_BOMB || startRune.status?.corrupted) { c++; continue; }
                
                let match = [{ r, c }];
                let nc = c + 1;
                while (nc < COLS && getRune(r, nc)?.color === startRune.color && getRune(r, nc)?.type !== RUNE_COLOR_BOMB && !getRune(r, nc)?.status?.corrupted) {
                    match.push({ r, c: nc });
                    nc++;
                }
                if (match.length >= 3) groups.push({ runes: match, direction: 'horizontal' });
                c = nc;
            }
        }
    
        for (let c = 0; c < COLS; c++) {
            for (let r = 0; r < ROWS; ) {
                const startRune = getRune(r, c);
                if (!startRune || startRune.type === RUNE_COLOR_BOMB || startRune.status?.corrupted) { r++; continue; }
                
                let match = [{ r, c }];
                let nr = r + 1;
                while (nr < ROWS && getRune(nr, c)?.color === startRune.color && getRune(nr, c)?.type !== RUNE_COLOR_BOMB && !getRune(nr, c)?.status?.corrupted) {
                    match.push({ r: nr, c });
                    nr++;
                }
                if (match.length >= 3) groups.push({ runes: match, direction: 'vertical' });
                r = nr;
            }
        }
    
        if (groups.length > 0) logStep(`ÊâæÂà∞ ${groups.length} ÁµÑÂåπÈÖç„ÄÇ`);
        return { groups };
    }


    // --- ËôïÁêÜÂåπÈÖçÁµÑ ---
    async function handleMatchGroups(matchInfo, swapPoint) {
        const allMatchedRunes = new Set();
        const adjacentToMatch = new Set();
        const directions = [[-1,0], [1,0], [0,-1], [0,1]];

        matchInfo.groups.forEach(group => group.runes.forEach(p => {
            allMatchedRunes.add(`${p.r},${p.c}`);
            directions.forEach(([dr, dc]) => {
                adjacentToMatch.add(`${p.r + dr},${p.c + dc}`);
            });
        }));

        // Cleanse corrupted runes
        adjacentToMatch.forEach(coordStr => {
            const [r, c] = coordStr.split(',').map(Number);
            const rune = board[r]?.[c];
            if (rune?.status?.corrupted) {
                delete rune.status.corrupted;
                logStep(`Á¨¶Êñá (${r},${c}) Ë¢´Ê∑®Âåñ!`);
            }
        });
        
        const runesByColor = {};
        allMatchedRunes.forEach(coordStr => {
            const [r, c] = coordStr.split(',').map(Number);
            const rune = board[r]?.[c];
            if (rune && rune.color !== undefined) {
                if (!runesByColor[rune.color]) runesByColor[rune.color] = 0;
                runesByColor[rune.color]++;
            }
        });

        // Handle boss shield mechanic
        const boss = enemies.find(e => e.rank === 'boss' && e.hp > 0);
        if (boss && boss.shieldHp > 0 && runesByColor[boss.shieldColor]) {
            const shieldDamage = runesByColor[boss.shieldColor];
            boss.shieldHp = Math.max(0, boss.shieldHp - shieldDamage);
            logStep(`Â∞ç Boss Ë≠∑ÁõæÈÄ†Êàê ${shieldDamage} ÈªûÂÇ∑ÂÆ≥, Ââ©È§ò ${boss.shieldHp}`);
            updateCharacterUI(boss.id);
            if (boss.shieldHp === 0) {
                logStep("Boss Ë≠∑ÁõæË¢´ÊâìÁ†¥! Boss ÊöàÁú©!");
                boss.status.stunned = 2; // Stun for 1 enemy turn (2 player turns)
                triggerScreenShake();
            }
        }

        for (const group of matchInfo.groups) {
            if (group.runes.length > 0) {
                const firstRunePos = group.runes[0];
                const runeData = board[firstRunePos.r]?.[firstRunePos.c];
                if (runeData) {
                    const player = players.find(p => p.colorIndex === runeData.color);
                    if (player && player.hp > 0) {
                        if (group.runes.length > 3) {
                            await triggerPlayerSkill(player, group.runes.length);
                        } else {
                            const livingEnemies = enemies.filter(e => e.hp > 0);
                            if (livingEnemies.length > 0) {
                                const target = livingEnemies[Math.floor(Math.random() * livingEnemies.length)];
                                applyDamageToEnemy(target, group.runes.length * BASE_DAMAGE_PER_RUNE);
                            }
                        }
                    }
                }
            }
        }
        
        const specialRunesToCreate = [];
        const handledCreationCoords = new Set();
        const getCreationPos = (group, swapPoint) => {
            if (swapPoint && group.runes.some(p => p.r === swapPoint.r && p.c === swapPoint.c)) {
                return swapPoint;
            }
            return group.runes[Math.floor(group.runes.length / 2)];
        };

        const runeToGroups = new Map();
        matchInfo.groups.forEach((group, index) => {
            group.runes.forEach(p => {
                const key = `${p.r},${p.c}`;
                if (!runeToGroups.has(key)) runeToGroups.set(key, []);
                runeToGroups.get(key).push(index);
            });
        });

        for (const [key, groupIndices] of runeToGroups.entries()) {
            if (groupIndices.length > 1 && !handledCreationCoords.has(key)) {
                const [r, c] = key.split(',').map(Number);
                const sourceRune = board[r]?.[c];
                if (sourceRune) {
                    specialRunesToCreate.push({ pos: {r, c}, type: RUNE_BOMB, color: sourceRune.color });
                    handledCreationCoords.add(key);
                }
            }
        }

        matchInfo.groups.forEach(group => {
            const creationPos = getCreationPos(group, swapPoint);
            const key = `${creationPos.r},${creationPos.c}`;

            if (handledCreationCoords.has(key)) return;

            if (group.runes.length >= 5) {
                specialRunesToCreate.push({ pos: creationPos, type: RUNE_COLOR_BOMB, color: undefined });
                handledCreationCoords.add(key);
            } else if (group.runes.length === 4) {
                const sourceRune = board[creationPos.r]?.[creationPos.c];
                if (sourceRune) {
                    const newType = group.direction === 'horizontal' ? RUNE_STRIPED_H : RUNE_STRIPED_V;
                    specialRunesToCreate.push({ pos: creationPos, type: newType, color: sourceRune.color });
                    handledCreationCoords.add(key);
                }
            }
        });
        
        specialRunesToCreate.forEach(special => {
             logStep(`ÁîüÊàê ${special.type} Êñº (${special.pos.r},${special.pos.c})`);
             board[special.pos.r][special.pos.c] = { color: special.color, type: special.type, status: {} };
             allMatchedRunes.delete(`${special.pos.r},${special.pos.c}`);
        });

        const destroyedCoords = Array.from(allMatchedRunes).map(s => s.split(',').map(Number));
        await destroyRunes(destroyedCoords, true);
    }
    
    // --- ËôïÁêÜÁâπÊÆäÁµÑÂêà ---
    async function handleSpecialCombination(r1, c1, r2, c2, rune1, rune2) {
        AudioManager.playSpecial();
        triggerScreenFlash('rgba(252, 163, 17, 0.5)');
        logStep(`Ëß∏ÁôºÁµÑÂêàÊäÄ: ${rune1.type} + ${rune2.type}`);
        
        const originR = r1, originC = c1; 
        const runesToDestroyCoords = new Set([`${r1},${c1}`, `${r2},${c2}`]);
        const types = [rune1.type, rune2.type].sort();

        if (types.includes(RUNE_COLOR_BOMB)) {
            const otherRune = (rune1.type === RUNE_COLOR_BOMB) ? rune2 : rune1;
            triggerScreenShake();
            if (otherRune.type === RUNE_COLOR_BOMB) {
                logStep("ÁµÑÂêàÊäÄ: ÂÖ®Áï´Èù¢Ê∏ÖÈô§!");
                for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) runesToDestroyCoords.add(`${r},${c}`);
            } 
            else if (otherRune.type === RUNE_STRIPED_H || otherRune.type === RUNE_STRIPED_V) {
                logStep("ÁµÑÂêàÊäÄ: ÂÖ®È´îËÆäÊèõ‰∏¶ÂºïÁàÜ!");
                const colorToChange = otherRune.color;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                       if (board[r]?.[c]?.color === colorToChange) {
                           board[r][c].type = (Math.random() > 0.5) ? RUNE_STRIPED_H : RUNE_STRIPED_V;
                           runesToDestroyCoords.add(`${r},${c}`);
                       }
                   }
               }
            }
            else if (otherRune.type === RUNE_BOMB) {
                logStep("ÁµÑÂêàÊäÄ: ÂÖ®È´îÈ°èËâ≤ÂºïÁàÜ!");
                const colorToClear = otherRune.color;
                for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                    if (board[r]?.[c]?.color === colorToClear) {
                        runesToDestroyCoords.add(`${r},${c}`);
                    }
                }
                runesToDestroyCoords.forEach(coord => {
                    const [r, c] = coord.split(',').map(Number);
                    if (board[r]?.[c]) board[r][c].type = RUNE_BOMB;
                });
            }
        } 
        else if (types.every(t => t === RUNE_BOMB)) {
            logStep("ÁµÑÂêàÊäÄ: Â∑®Â§ßÁàÜÁÇ∏!");
            triggerScreenShake();
            const midR = Math.round((r1+r2)/2), midC = Math.round((c1+c2)/2);
            for (let i = -2; i <= 2; i++) for (let j = -2; j <= 2; j++) {
                const nr = midR + i, nc = midC + j;
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) runesToDestroyCoords.add(`${nr},${nc}`);
            }
        }
        else if (types.includes(RUNE_BOMB) && (types.includes(RUNE_STRIPED_H) || types.includes(RUNE_STRIPED_V))) {
            logStep("ÁµÑÂêàÊäÄ: ÂçÅÂ≠óÂ∑®Â§ßÁàÜÁÇ∏!");
            triggerScreenShake();
            const effectOrigin = rune1.type === RUNE_BOMB ? {r:r1, c:c1} : {r:r2, c:c2};
            for(let i of [effectOrigin.r - 1, effectOrigin.r, effectOrigin.r + 1]) {
                if(i >=0 && i < ROWS) for (let j = 0; j < COLS; j++) runesToDestroyCoords.add(`${i},${j}`);
            }
            for(let i of [effectOrigin.c - 1, effectOrigin.c, effectOrigin.c + 1]) {
                if(i >=0 && i < COLS) for (let j = 0; j < ROWS; j++) runesToDestroyCoords.add(`${j},${i}`);
            }
        }
        else if (types[0].startsWith('striped') && types[1].startsWith('striped')) {
             logStep("ÁµÑÂêàÊäÄ: ÂçÅÂ≠óÁàÜÁÇ∏!");
             for (let i = 0; i < COLS; i++) runesToDestroyCoords.add(`${originR},${i}`);
             for (let i = 0; i < ROWS; i++) runesToDestroyCoords.add(`${i},${originC}`);
        }
        
        const destroyedCoords = Array.from(runesToDestroyCoords).map(s => s.split(',').map(Number));
        await destroyRunes(destroyedCoords, false);
    }
    
    // --- Á¨¶ÊñáÈä∑ÊØÄ&ÊéâËêΩ ---
    async function destroyRunes(coords, isNormalMatch) {
        if (coords.length === 0) return;
        
        let finalCoordsToDestroy = new Set();
        let coordsToProcess = coords.map(c => `${c[0]},${c[1]}`);
        const processed = new Set();
        const runesByColor = {};

        while (coordsToProcess.length > 0) {
            const coordStr = coordsToProcess.pop();
            if (processed.has(coordStr)) continue;
            processed.add(coordStr);
            finalCoordsToDestroy.add(coordStr);

            const [r, c] = coordStr.split(',').map(Number);
            const runeData = board[r]?.[c];

            if (runeData) {
                if (runeData.color !== undefined) {
                    if (!runesByColor[runeData.color]) runesByColor[runeData.color] = 0;
                    runesByColor[runeData.color]++;
                }
                if(runeData.burning) delete runeData.burning;
                if (runeData.type !== RUNE_NORMAL) {
                    AudioManager.playSpecial();
                    const effectCoords = getSpecialRuneEffectCoords(r, c);
                    effectCoords.forEach(cStr => {
                        if (!processed.has(cStr)) coordsToProcess.push(cStr);
                    });
                }
            }
        }

        if (isNormalMatch) AudioManager.playMatch(comboCounter > 0 ? comboCounter : 1);
        
        const finalCoordsArray = Array.from(finalCoordsToDestroy).map(s => s.split(',').map(Number));
        logStep(`Á∏ΩË®à ${finalCoordsArray.length} ÂÄãÁ¨¶ÊñáÂ∞áË¢´Èä∑ÊØÄ„ÄÇ`);
        
        // Grant MP to players
        if (playerTurnTimerStarted) {
            for (const color in runesByColor) {
                const player = players.find(p => p.colorIndex == color);
                if (player && player.hp > 0) {
                    player.mp = Math.min(player.maxMp, player.mp + runesByColor[color] * MP_PER_RUNE);
                    updateCharacterUI(player.id);
                }
            }
        }

        if (playerTurnTimerStarted) { 
           let damage = finalCoordsArray.length * BASE_DAMAGE_PER_RUNE * (isNormalMatch ? 1 : 0.7);
           const livingEnemies = enemies.filter(e => e.hp > 0);
           if (livingEnemies.length > 0) {
              const target = livingEnemies[Math.floor(Math.random() * livingEnemies.length)];
              applyDamageToEnemy(target, damage);
           }
        }
        
        updateScoreAndXP(finalCoordsArray.length);

        for (const [r, c] of finalCoordsArray) {
            if (board[r]?.[c]) {
                const runeElement = document.querySelector(`#game-board [data-row='${r}'][data-col='${c}']`);
                if (runeElement) runeElement.classList.add('matched');
                board[r][c] = null;
            }
        }

        await sleep(500);
        await animateAndApplyDropsAndFills();
    }
    
    function getSpecialRuneEffectCoords(r, c) {
        const coords = new Set();
        const runeData = board[r]?.[c];
        if (!runeData) return coords;

        if (runeData.type === RUNE_BOMB) {
            for (let i = -1; i <= 1; i++) for (let j = -1; j <= 1; j++) {
                const nr = r + i, nc = c + j;
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) coords.add(`${nr},${nc}`);
            }
        } else if (runeData.type === RUNE_STRIPED_H) {
            for (let i = 0; i < COLS; i++) coords.add(`${r},${i}`);
        } else if (runeData.type === RUNE_STRIPED_V) {
            for (let i = 0; i < ROWS; i++) coords.add(`${i},${c}`);
        } else if (runeData.type === RUNE_COLOR_BOMB) {
            const colorsOnBoard = {};
            for (let br = 0; br < ROWS; br++) for (let bc = 0; bc < COLS; bc++) {
                if (board[br]?.[bc]?.type === RUNE_NORMAL) {
                    colorsOnBoard[board[br][bc].color] = (colorsOnBoard[board[br][bc].color] || 0) + 1;
                }
            }
            let maxCount = 0;
            let colorToClear = -1;
            for (const color in colorsOnBoard) {
                if (colorsOnBoard[color] > maxCount) {
                    maxCount = colorsOnBoard[color];
                    colorToClear = parseInt(color);
                }
            }
            if (colorToClear !== -1) {
                logStep(`3ËôüÁ¨¶ÊñáË¢´ÂãïËß∏Áôº,Ê∂àÈô§ÊâÄÊúâÈ°èËâ≤ÁÇ∫ ${colorToClear} ÁöÑÁ¨¶Êñá„ÄÇ`);
                for (let br = 0; br < ROWS; br++) for (let bc = 0; bc < COLS; bc++) {
                    if (board[br]?.[bc]?.color === colorToClear) coords.add(`${br},${bc}`);
                }
            }
        }
        return coords;
    }

    // --- Êïµ‰∫∫ÂõûÂêà ---
    async function enemyTurn() {
        if (testModeActive) return;
        logStep("-------- Êïµ‰∫∫ÂõûÂêàÈñãÂßã ----------");
        isSwapping = true;
        playerTurnTimerStarted = false;
        clearInterval(roundTimer);
        clearInterval(countdownInterval);
        document.querySelector('.countdown-bar')?.classList.remove('urgent');

        // Clear intents before new ones are calculated
        renderEnemyIntents(true); 

        let livingPlayers = players.filter(p => p.hp > 0);
        const livingEnemies = enemies.filter(e => e.hp > 0);

        if (livingEnemies.length === 0 || livingPlayers.length === 0) {
            isSwapping = false;
            if(livingPlayers.length > 0) prepareNextPlayerTurn();
            return;
        }

        for (const attacker of livingEnemies) {
            while (isExecutingUltimate) { await sleep(100); }
            if (players.filter(p => p.hp > 0).length === 0) break;
            
            if (attacker.status?.stunned > 0) {
                logStep(`Êïµ‰∫∫ ${attacker.id} ÊöàÁú©‰∏≠, Ë∑≥ÈÅéÂõûÂêà„ÄÇ`);
                attacker.status.stunned--;
                continue;
            }

            attacker.skillCooldown--;
            const skillChanceIncrease = (currentWave - 1) * 0.1;
            
            if (attacker.skillCooldown <= 0 || Math.random() < skillChanceIncrease) {
                logStep(`Êïµ‰∫∫ ${attacker.id} ÊñΩÊîæÊäÄËÉΩ: ${attacker.skill.name}`);
                showFloatingText(attacker.skill.name, attacker.element);
                const attackerIcon = attacker.element?.querySelector('.char-icon');
                if(attackerIcon) attackerIcon.classList.add('casting-skill');
                triggerScreenFlash('rgba(157, 78, 221, 0.4)');
                await sleep(500);
                await attacker.skill.execute(attacker);
                if(attackerIcon) attackerIcon.classList.remove('casting-skill');
                attacker.skillCooldown = Math.floor(Math.random() * 3) + 2;
            } else {
                logStep(`Êïµ‰∫∫ ${attacker.id} ÈñãÂßãÊôÆÈÄöÊîªÊìä`);
                const target = livingPlayers[Math.floor(Math.random() * livingPlayers.length)];
                logStep(`\t -> ÊîªÊìäÁé©ÂÆ∂ ${target.id}`);
                await showAttackVisuals(attacker, target);
                applyDamageToPlayer(target, ENEMY_BASE_DAMAGE, attacker);
            }
            
            // Set up telegraph for next turn
            if (attacker.skillCooldown === 1) {
                attacker.telegraphingSkill = attacker.skill;
            } else {
                delete attacker.telegraphingSkill;
            }

            livingPlayers = players.filter(p => p.hp > 0);
            await sleep(500);
        }

        logStep("---------- Êïµ‰∫∫ÂõûÂêàÁµêÊùü ----------");
        await cascadeMatches();
    }
    
    async function applyDamageToEnemy(target, damage, attacker = null) {
        if (attacker) {
            await showAttackVisuals(attacker, target);
        }
        
        let finalDamage = damage;
        
        if (target.rank === 'boss' && target.shieldHp > 0) {
            finalDamage *= 0.1; 
        } else if (target.status?.stunned > 0) {
            finalDamage *= 2; 
        }

        let comboBonus = 0;
        if (comboCounter > 1) {
            comboBonus = finalDamage * (comboCounter - 1) * COMBO_DAMAGE_BONUS;
            finalDamage += comboBonus;
        }
        finalDamage = Math.round(finalDamage);

        target.hp = Math.max(0, target.hp - finalDamage);
        AudioManager.playHit();
        updateCharacterUI(target.id);
        createFloatingText(`-${finalDamage}`, target.element, 'enemy-damage');
        if (comboBonus > 0) {
            createFloatingText(`+${Math.round(comboBonus)} ÈÄ£Êìä!`, target.element, 'combo');
        }

        if (target.rank === 'elite' && target.modifiers?.includes('thorns')) {
            const thornDamage = Math.max(1, Math.round(finalDamage * 0.2));
            logStep(`Á≤æËã±Êïµ‰∫∫ ${target.id} ÁöÑËçäÊ£òÂèçÂΩà ${thornDamage} ÈªûÂÇ∑ÂÆ≥!`);
            const randomPlayer = players.find(p => p.hp > 0);
            if(randomPlayer) applyDamageToPlayer(randomPlayer, thornDamage);
        }

        const icon = target.element?.querySelector('.char-icon');
        if (icon) {
            icon.classList.add('damaged');
            setTimeout(() => icon.classList.remove('damaged'), 300);
        }
        if (target.hp === 0) {
            logStep(`Êïµ‰∫∫ ${target.id} Â∑≤Ë¢´ÊìäÊïó!`);
            if (enemies.every(e => e.hp === 0)) {
                logStep("ÊâÄÊúâÊïµ‰∫∫ÈÉΩÂ∑≤Ë¢´ÊìäÊïó!Ê∫ñÂÇô‰∏ã‰∏ÄÊ≥¢!");
                clearInterval(roundTimer);
                setTimeout(startNextWave, 1500);
            }
        }
    }

    function applyDamageToPlayer(target, damage, attacker = null) {
        damage = Math.round(damage);
        target.hp = Math.max(0, target.hp - damage);
        AudioManager.playDamage();
        triggerScreenShake();
        updateCharacterUI(target.id);
        createFloatingText(`-${damage}`, target.element, 'player-damage');
        updatePlayerUI();

        const icon = target.element?.querySelector('.char-icon');
        if (icon) {
            icon.classList.add('damaged');
            setTimeout(() => icon.classList.remove('damaged'), 300);
        }
        if (target.hp === 0) {
            logStep(`Áé©ÂÆ∂ ${target.id} Â∑≤Ë¢´ÊìäÊïó!`);
            if (players.every(p => p.hp === 0)) {
                logStep("ÊâÄÊúâËã±ÈõÑÈÉΩÂ∑≤Èô£‰∫°!ÈÅäÊà≤Â§±Êïó!");
                clearInterval(roundTimer);
                showGameOverScreen();
            }
        }
    }

    async function animateAndApplyDropsAndFills() {
        logStep("Á¨¶Êñá‰∏ãËêΩ‰∏¶Â°´ÂÖÖÊñ∞Á¨¶Êñá (ÂãïÁï´)...");
        dropRunes();

        const newRunes = [];
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (board[r] && !board[r][c]) {
                    newRunes.push({ r, c });
                }
            }
        }
        if (newRunes.length === 0) {
            renderBoard(false);
            return;
        }

        fillNewRunes();
        renderBoard(true);

        const runeProto = gameBoardElement.querySelector('.rune');
        if (!runeProto) { renderBoard(false); return; }
        const runeHeight = runeProto.offsetHeight + 3; // 3 is gap

        newRunes.forEach(({ r, c }) => {
            const runeElement = document.querySelector(`[data-id='${r}-${c}']`);
            if (runeElement) {
                const newRunesInCol = newRunes.filter(nr => nr.c === c);
                const highestNewRuneRow = Math.min(...newRunesInCol.map(nr => nr.r));
                const startYPos = -(highestNewRuneRow + 1) * runeHeight;

                runeElement.style.setProperty('--start-y', `${startYPos}px`);
                runeElement.classList.add('dropping');
                runeElement.style.animationDelay = `${(r - highestNewRuneRow) * 0.06}s`;
            }
        });

        await sleep(500 + newRunes.length * 6);
        renderBoard(false);
    }


    function dropRunes() {
        for (let c = 0; c < COLS; c++) {
            let emptyRow = ROWS - 1;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r]?.[c]) {
                    if (r !== emptyRow) {
                        board[emptyRow][c] = board[r][c];
                        board[r][c] = null;
                    }
                    emptyRow--;
                }
            }
        }
    }

    function fillNewRunes() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (board[r] && !board[r][c]) {
                    board[r][c] = { color: generateSafeColor(r, c), type: RUNE_NORMAL, status: {} };
                }
            }
        }
    }

    function updateScoreAndXP(matchCount) {
        score += matchCount * 10 * (1 + (comboCounter - 1) * 0.1) * currentWave;
        const xpGained = matchCount * XP_PER_RUNE;
        playerXP += xpGained;

        if (playerXP >= xpToNextLevel) {
            levelUp();
        }
        updatePlayerUI();
    }

    function levelUp() {
        playerLevel++;
        playerXP -= xpToNextLevel;
        xpToNextLevel = Math.round(xpToNextLevel * 1.5);
        logStep(`Áé©ÂÆ∂ÂçáÁ¥ö! ÁèæÂú®Á≠âÁ¥ö ${playerLevel}!`);
        
        AudioManager.playLevelUp();
        triggerScreenFlash('rgba(255, 215, 0, 0.5)');
        showFloatingText("Á≠âÁ¥öÊèêÂçá!", battleSceneElement, "level-up");
        
        BASE_DAMAGE_PER_RUNE = Math.round(INITIAL_BASE_DAMAGE_PER_RUNE * Math.pow(1.05, playerLevel - 1));

        players.forEach(p => {
            p.maxHp = Math.round(p.baseMaxHp * Math.pow(1.05, playerLevel - 1));
            if (p.hp > 0) {
                const healAmount = Math.round(p.maxHp * 0.50);
                p.hp = Math.min(p.maxHp, p.hp + healAmount);
                createFloatingText(`+${healAmount}`, p.element, 'heal');
            }
        });
        updateAllCharacterUI();

        if (playerXP >= xpToNextLevel) { levelUp(); }
        updatePlayerUI();
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // --- SKILL & STATUS EFFECT FUNCTIONS ---
    
    function showFloatingText(text, onElement, type = '') {
        if (!battleSceneElement) return;
        const floatingText = document.createElement('div');
        floatingText.textContent = text;
        floatingText.className = `floating-text ${type}`;
        battleSceneElement.appendChild(floatingText);
        setTimeout(() => floatingText.remove(), type ? 2000 : 1500);
    }
    
    function createFloatingText(text, targetElement, type = 'enemy-damage') {
        if (!targetElement || !battleSceneElement) return;
        const textElement = document.createElement('div');
        textElement.textContent = text;
        textElement.className = `floating-damage-text ${type}`;
        
        const rect = targetElement.getBoundingClientRect();
        const wrapperRect = gameWrapper.getBoundingClientRect();
        const initialLeft = rect.left - wrapperRect.left + (rect.width / 2);
        let initialTop = rect.top - wrapperRect.top + (rect.height / 2);

        if (type === 'combo') initialTop += 20;

        textElement.style.left = `${initialLeft}px`;
        textElement.style.top = `${initialTop}px`;
        textElement.style.transform = 'translateX(-50%)';

        battleSceneElement.appendChild(textElement);
        setTimeout(() => textElement.remove(), 1200);
    }

    function showComboText(count) {
        if (!comboDisplayElement) return;
        comboDisplayElement.textContent = `ÈÄ£Êìä x${count}!`;
        comboDisplayElement.classList.add('show');
    }

    function hideComboText() {
        if (!comboDisplayElement) return;
        comboDisplayElement.classList.remove('show');
    }

    function triggerScreenShake() {
        if (!gameWrapper) return;
        gameWrapper.classList.remove('shake');
        void gameWrapper.offsetWidth; // Trigger reflow
        gameWrapper.classList.add('shake');
    }
    
    function triggerScreenFlash(color) {
        if (!effectOverlay) return;
        effectOverlay.style.backgroundColor = color;
        effectOverlay.classList.remove('flash');
        void effectOverlay.offsetWidth;
        effectOverlay.classList.add('flash');
    }

    async function triggerPlayerSkill(player, power) {
        logStep(`Áé©ÂÆ∂ ${player.id} ÊñΩÊîæÊäÄËÉΩ: ${player.skill.name}`);
        showFloatingText(player.skill.name, player.element);
        const icon = player.element?.querySelector('.char-icon');
        if (icon) icon.classList.add('casting-skill');
        triggerScreenFlash('rgba(252, 163, 17, 0.4)');
        await sleep(500);
        await player.skill.execute(player, power);
        if (icon) icon.classList.remove('casting-skill');
    }
    
    async function handleColorBombActivation(pos, colorToClear) {
        AudioManager.playSpecial();
        triggerScreenShake();
        logStep(`Ëß∏Áôº 3ËôüÁ¨¶Êñá, Ê∂àÈô§ÊâÄÊúâÈ°èËâ≤ÁÇ∫ ${colorToClear} ÁöÑÁ¨¶Êñá„ÄÇ`);
        const runesToDestroyCoords = new Set([`${pos.r},${pos.c}`]);
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(board[r]?.[c]?.color === colorToClear) {
                    runesToDestroyCoords.add(`${r},${c}`);
                }
            }
        }
        const destroyedCoords = Array.from(runesToDestroyCoords).map(s => s.split(',').map(Number));
        await destroyRunes(destroyedCoords, false);
    }

    // --- Player Skill Implementations ---
    async function playerSkillSingleTarget(player, power) {
        const livingEnemies = enemies.filter(e => e.hp > 0);
        if (livingEnemies.length === 0) return;
        const target = livingEnemies.sort((a,b) => b.hp - a.hp)[0];
        const damage = power * BASE_DAMAGE_PER_RUNE * 2;
        await applyDamageToEnemy(target, damage, player);
    }

    async function playerSkillAoeDamage(player, power) {
        const livingEnemies = enemies.filter(e => e.hp > 0);
        if (livingEnemies.length === 0) return;
        const damage = power * BASE_DAMAGE_PER_RUNE * 0.8;
        // For AoE, we don't show individual attack rays to avoid chaos.
        // The skill glow and screen flash provide enough feedback.
        for (const e of livingEnemies) {
            applyDamageToEnemy(e, damage);
        }
    }
    
    function playerSkillHealLowest(player, power) {
        const livingPlayers = players.filter(p => p.hp > 0);
        if(livingPlayers.length === 0) return;
        const target = livingPlayers.sort((a,b) => (a.hp/a.maxHp) - (b.hp/b.maxHp))[0];
        const healAmount = power * 5;
        target.hp = Math.min(target.maxHp, target.hp + healAmount);
        AudioManager.playHeal();
        updateCharacterUI(target.id);
        createFloatingText(`+${healAmount}`, target.element, 'heal');
    }

    function playerSkillAoeHeal(player, power) {
        const livingPlayers = players.filter(p => p.hp > 0);
        if(livingPlayers.length === 0) return;
        triggerScreenFlash('rgba(144, 238, 144, 0.4)');
        const healAmount = power * 2;
        livingPlayers.forEach(p => {
             p.hp = Math.min(p.maxHp, p.hp + healAmount);
             updateCharacterUI(p.id);
             createFloatingText(`+${healAmount}`, p.element, 'heal');
        });
        AudioManager.playHeal();
    }
    
    async function playerSkillSingleTargetDebuff(player, power) {
        const livingEnemies = enemies.filter(e => e.hp > 0);
        if (livingEnemies.length === 0) return;
        const target = livingEnemies[Math.floor(Math.random() * livingEnemies.length)];
        const damage = power * BASE_DAMAGE_PER_RUNE;
        await applyDamageToEnemy(target, damage, player);
    }

    // Player ULTIMATE skills
    async function playerUltimate_FieryRage(player) {
        logStep(`Áé©ÂÆ∂ ${player.id} ÊñΩÊîæÁµÇÊ•µÊäÄËÉΩ: ÁÖâÁçÑÁÅ´Êµ∑!`);
        triggerScreenShake();
        const runesToConvert = [];
        for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) {
            if (board[r]?.[c]?.color !== player.colorIndex) runesToConvert.push({r, c});
        }}
        runesToConvert.sort(() => 0.5 - Math.random());
        const count = Math.floor(runesToConvert.length / 3);
        const convertedRunes = runesToConvert.slice(0, count);

        convertedRunes.forEach(({r, c}) => { if (board[r]?.[c]) board[r][c].color = player.colorIndex; });
        if (convertedRunes.length > 0) {
            const {r, c} = convertedRunes[0];
            if(board[r]?.[c]) board[r][c].type = RUNE_BOMB;
        }
        renderBoard(true);
        await sleep(300);
        await cascadeMatches();
    }
    
    async function playerUltimate_FreezeAll(player) {
        logStep(`Áé©ÂÆ∂ ${player.id} ÊñΩÊîæÁµÇÊ•µÊäÄËÉΩ: ÁµïÂ∞çÈõ∂Â∫¶!`);
        triggerScreenFlash('rgba(173, 216, 230, 0.5)');
        enemies.forEach(e => {
            if (e.hp > 0) e.status.stunned = (e.rank === 'boss' ? 2 : 4);
        });
        await cascadeMatches();
    }

    async function playerUltimate_ExecuteLowest(player) {
        logStep(`Áé©ÂÆ∂ ${player.id} ÊñΩÊîæÁµÇÊ•µÊäÄËÉΩ: ÊöóÂΩ±Â•áË•≤!`);
        const livingEnemies = enemies.filter(e => e.hp > 0);
        if (livingEnemies.length === 0) { await cascadeMatches(); return; }
        const target = livingEnemies.sort((a,b) => (a.hp/a.maxHp) - (b.hp/b.maxHp))[0];
        const damage = target.maxHp * 0.5; // 50% max HP damage
        await applyDamageToEnemy(target, damage, player);
        await sleep(300);
        await cascadeMatches();
    }

    async function playerUltimate_CleanseAndHeal(player) {
        logStep(`Áé©ÂÆ∂ ${player.id} ÊñΩÊîæÁµÇÊ•µÊäÄËÉΩ: Ëá™ÁÑ∂Á•ùÁ¶è!`);
        triggerScreenFlash('rgba(144, 238, 144, 0.5)');
        // Cleanse board
        for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) {
            if (board[r]?.[c]) {
                delete board[r][c].burning;
                if(board[r][c].status) delete board[r][c].status.corrupted;
            }
        }}
        renderBoard(false);
        // Heal party
        const healAmount = player.maxHp * 0.5;
        players.forEach(p => {
            if (p.hp > 0) {
                p.hp = Math.min(p.maxHp, p.hp + healAmount);
                updateCharacterUI(p.id);
                createFloatingText(`+${Math.round(healAmount)}`, p.element, 'heal');
            }
        });
        await sleep(300);
        await cascadeMatches();
    }

    async function playerUltimate_CreateBombs(player) {
        logStep(`Áé©ÂÆ∂ ${player.id} ÊñΩÊîæÁµÇÊ•µÊäÄËÉΩ: Èõ∑Á•û‰πãÊÄí!`);
        const emptyRunes = [];
        for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) {
            if (board[r]?.[c]?.type === RUNE_NORMAL) emptyRunes.push({r, c});
        }}
        emptyRunes.sort(() => 0.5 - Math.random());
        for(let i=0; i<4; i++) {
            if (emptyRunes[i]) {
                const {r, c} = emptyRunes[i];
                board[r][c] = { color: player.colorIndex, type: RUNE_BOMB, status: {} };
            }
        }
        renderBoard(true);
        await sleep(300);
        await cascadeMatches();
    }


    // --- Enemy Skill Implementations ---
    async function enemyCastFire(caster) {
        AudioManager.playBurn();
        triggerScreenFlash('rgba(255, 100, 0, 0.3)');
        const emptyRunes = [];
        for (let r=0; r<ROWS; r++) { for (let c=0; c<COLS; c++) {
            if (board[r]?.[c] && !board[r][c].burning) emptyRunes.push({r,c});
        }}
        for (let i=0; i<3; i++) {
            if (emptyRunes.length === 0) break;
            const randIndex = Math.floor(Math.random() * emptyRunes.length);
            const {r, c} = emptyRunes.splice(randIndex, 1)[0];
            if (board[r]?.[c]) board[r][c].burning = true;
        }
        renderBoard(false);
    }
    
    async function enemyCastGroupAttack(caster) {
        const livingPlayers = players.filter(p => p.hp > 0);
        for (const p of livingPlayers) {
            applyDamageToPlayer(p, ENEMY_BASE_DAMAGE * 0.7);
        }
    }
    
    async function enemyCastFreeze(caster) {
        AudioManager.playDebuff();
        if (frozenRuneColor !== null) {
            logStep(`ÂÜ∞ÂáçÊäÄËÉΩÂ§±ÊïóÔºåÂ∑≤ÊúâÈ°èËâ≤Ë¢´ÂÜ∞Âáç„ÄÇËΩâÁÇ∫ÊôÆÈÄöÊîªÊìä„ÄÇ`);
            const livingPlayers = players.filter(p => p.hp > 0);
            if (livingPlayers.length > 0) {
                const target = livingPlayers[Math.floor(Math.random() * livingPlayers.length)];
                await showAttackVisuals(caster, target);
                applyDamageToPlayer(target, ENEMY_BASE_DAMAGE, caster);
            }
            return;
        }
        const availableColors = Array.from({length: RUNE_TYPES}, (_, i) => i);
        const targetColor = availableColors[Math.floor(Math.random() * availableColors.length)];
        const targetableRunes = [];
        for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) {
            const rune = board[r]?.[c];
            if (rune?.color === targetColor && rune.type === RUNE_NORMAL) targetableRunes.push(rune);
        }}
        if (targetableRunes.length < 3) {
             logStep(`ÂÜ∞ÂáçÊäÄËÉΩÂ§±ÊïóÔºåÁõÆÊ®ôÈ°èËâ≤Á¨¶ÊñáÂ§™Â∞ë„ÄÇËΩâÁÇ∫ÊôÆÈÄöÊîªÊìä„ÄÇ`);
            const livingPlayers = players.filter(p => p.hp > 0);
            if (livingPlayers.length > 0) {
                const target = livingPlayers[0];
                await showAttackVisuals(caster, target);
                applyDamageToPlayer(target, ENEMY_BASE_DAMAGE, caster);
            }
            return;
        }
        const freezePercent = Math.random() * 0.2 + 0.1;
        const numToFreeze = Math.max(1, Math.floor(targetableRunes.length * freezePercent));
        for (let i = targetableRunes.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [targetableRunes[i], targetableRunes[j]] = [targetableRunes[j], targetableRunes[i]];
        }
        const runesToFreeze = targetableRunes.slice(0, numToFreeze);
        runesToFreeze.forEach(rune => {
            if (rune.status) rune.status.frozen = Math.floor(Math.random() * 3) + 3;
        });
        frozenRuneColor = targetColor;
        logStep(`${runesToFreeze.length} ÂÄã ${targetColor} Ëâ≤Á¨¶ÊñáË¢´ÂÜ∞Âáç‰∫Ü!`);
        renderBoard(false);
    }
    
    async function enemyCastRuneCorruption(caster) {
        AudioManager.playDebuff();
        let placed = 0;
        const availableRunes = [];
        for (let r=0; r<ROWS; r++) { for (let c=0; c<COLS; c++) {
            if (board[r]?.[c] && !board[r][c].status.corrupted) availableRunes.push({r, c});
        }}
        availableRunes.sort(() => 0.5 - Math.random());
        for (let i = 0; i < 3 && i < availableRunes.length; i++) {
            const {r, c} = availableRunes[i];
            const rune = board[r]?.[c];
            if (rune) {
                if (!rune.status) rune.status = {};
                rune.status.corrupted = true;
                placed++;
            }
        }
        logStep(`${placed} ÂÄãÁ¨¶ÊñáË¢´ËÖêÂåñ!`);
        renderBoard(false);
    }

    async function enemyCastFogOfWar(caster) {
        AudioManager.playDebuff();
        triggerScreenFlash('rgba(100, 100, 120, 0.4)');
        const startR = Math.floor(Math.random() * (ROWS - 2));
        const startC = Math.floor(Math.random() * (COLS - 2));
        const duration = Math.floor(Math.random() * 3) + 3; // 3-5 turns
        let foggedCount = 0;
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                const rune = board[startR + r]?.[startC + c];
                if (rune) {
                    if (!rune.status) rune.status = {};
                    rune.status.fog = duration;
                    foggedCount++;
                }
            }
        }
        logStep(`Ê£ãÁõ§ 3x3 ÂçÄÂüüË¢´Ëø∑ÈúßÁ±†ÁΩ©‰∫Ü ${duration} ÂõûÂêà!`);
        renderBoard(false);
    }

    // --- Board Effects ---
    async function handleBoardStatusEffects() {
        // --- Burning ---
        const burningRunes = [];
        for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
            if (board[r]?.[c]?.burning) burningRunes.push({r,c});
        }
        
        if (burningRunes.length > 0) {
            logStep(`ÁÅ´ÁÑ∞Â∞çÁé©ÂÆ∂ÈÄ†Êàê ${burningRunes.length * BURNING_DAMAGE} ÈªûÂÇ∑ÂÆ≥`);
            const livingPlayers = players.filter(p => p.hp > 0);
            if(livingPlayers.length > 0) {
                const target = livingPlayers[0];
                applyDamageToPlayer(target, burningRunes.length * BURNING_DAMAGE);
                AudioManager.playBurn();
            }
            await spreadFire(burningRunes);
        }

        // --- Corruption ---
        const newCorruptions = new Set();
        const directions = [[-1,0], [1,0], [0,-1], [0,1]];
        for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) {
            if (board[r]?.[c]?.status?.corrupted) {
                const [dr, dc] = directions[Math.floor(Math.random() * 4)];
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr]?.[nc] && !board[nr][nc].status?.corrupted) {
                    newCorruptions.add(`${nr},${nc}`);
                }
            }
        }}
        if (newCorruptions.size > 0) {
            logStep(`ËÖêÂåñËîìÂª∂Âà∞ ${newCorruptions.size} ÂÄãÊñ∞‰ΩçÁΩÆ!`);
            newCorruptions.forEach(coord => {
                const [r, c] = coord.split(',').map(Number);
                if (board[r]?.[c]?.status) board[r][c].status.corrupted = true;
            });
            renderBoard(false);
        }
    }

    async function spreadFire(burningRunes) {
        const newFlames = new Set();
        const directions = [[-1,0], [1,0], [0,-1], [0,1]];
        burningRunes.forEach(({r, c}) => {
             directions.forEach(([dr, dc]) => {
                // 33% chance to spread to each adjacent rune
                 if (Math.random() < 0.33) {
                     const nr = r + dr, nc = c + dc;
                     if (nr >=0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr]?.[nc] && !board[nr][nc].burning) {
                         newFlames.add(`${nr},${nc}`);
                     }
                 }
            });
        });
        if (newFlames.size > 0) {
            logStep(`ÁÅ´ÁÑ∞ËîìÂª∂Âà∞ ${newFlames.size} ÂÄãÊñ∞‰ΩçÁΩÆ!`);
            newFlames.forEach(coord => {
                const [r, c] = coord.split(',').map(Number);
                if (board[r]?.[c]) board[r][c].burning = true;
            });
            renderBoard(false);
        }
    }

    function renderEnemyIntents(clear = false) {
        document.querySelectorAll('.enemy-intent-icon').forEach(icon => icon.remove());
        if (clear) return;
        enemies.forEach(enemy => {
            if (enemy.hp > 0 && enemy.telegraphingSkill) {
                const intentIcon = document.createElement('div');
                intentIcon.className = 'enemy-intent-icon';
                intentIcon.textContent = enemy.telegraphingSkill.icon || '‚ùó';
                enemy.element?.querySelector('.char-icon')?.appendChild(intentIcon);
            }
        });
    }

    function showGameOverScreen() {
        if (!gameOverScreenElement) return;
        AudioManager.playGameOver();
        clearInterval(gameTimerInterval);
        const finalScoreEl = document.getElementById('final-score');
        const finalWaveEl = document.getElementById('final-wave');
        if (finalScoreEl) finalScoreEl.textContent = Math.round(score);
        if (finalWaveEl) finalWaveEl.textContent = currentWave;
        gameOverScreenElement.classList.add('show');
    }

    function resetGame() {
        logStep("--- ÈáçÁΩÆÈÅäÊà≤ ---");
        score = 0;
        playerLevel = 1;
        playerXP = 0;
        xpToNextLevel = 100;
        currentWave = 1;
        BASE_DAMAGE_PER_RUNE = INITIAL_BASE_DAMAGE_PER_RUNE;
        ENEMY_BASE_DAMAGE = INITIAL_ENEMY_BASE_DAMAGE;
        logCounter = 1;
        comboCounter = 0;
        frozenRuneColor = null;
        selectedRune = null;
        isSwapping = false;
        playerTurnTimerStarted = false;
        isExecutingUltimate = false;
        clearInterval(roundTimer);
        clearInterval(countdownInterval);


        if (gameOverScreenElement) gameOverScreenElement.classList.remove('show');
        initializeGame();
        
        logStep("--- ÈÅäÊà≤Â∑≤ÈáçÁΩÆ ---");
    }

    async function startNextWave() {
        currentWave++;
        logStep(`---------- Á¨¨ ${currentWave} Ê≥¢ ÈñãÂßã ----------`);
        AudioManager.playVictory();
        showFloatingText(`Á¨¨ ${currentWave} Ê≥¢`, battleSceneElement, "wave-start");
        
        players.forEach(p => {
            if (p.hp <= 0) {
                p.hp = p.maxHp * 0.20;
                logStep(`Ëã±ÈõÑ ${p.id} Â∑≤Âæ©Ê¥ª!`);
                createFloatingText('Âæ©Ê¥ª!', p.element, 'heal');
            }
        });

        const isBossWave = currentWave > 0 && currentWave % 10 === 0;
        const isEliteWave = currentWave > 0 && currentWave % 5 === 0 && !isBossWave;
        
        ENEMY_BASE_DAMAGE = Math.round(INITIAL_ENEMY_BASE_DAMAGE * Math.pow(1.1, currentWave - 1));
        
        enemies.forEach(e => {
            e.baseMaxHp = 100 * Math.pow(1.1, currentWave - 1);
            e.rank = 'normal';
            e.status = {};
            delete e.modifiers;
            delete e.telegraphingSkill;
            delete e.shieldHp;
        });

        if (isBossWave) {
            const boss = enemies.find(e => e.id === 'a');
            if (boss) {
                boss.rank = 'boss';
                boss.baseMaxHp *= 3;
                boss.shieldColor = 4; // Purple
                boss.shieldHp = 15 + (currentWave/10 * 5);
                logStep(`Boss Âá∫Áèæ! ${boss.id} Â∏∂Ëëó ${boss.shieldHp} ÈªûÁöÑË≠∑Áõæ!`);
            }
        } else if (isEliteWave) {
            const randomEnemy = enemies[Math.floor(Math.random() * enemies.length)];
            randomEnemy.rank = 'elite';
            randomEnemy.baseMaxHp *= 1.8;
            randomEnemy.modifiers = ['thorns'];
            logStep(`Á≤æËã±Êïµ‰∫∫Âá∫Áèæ! ${randomEnemy.id} ÊìÅÊúâ ËçäÊ£ò Â±¨ÊÄß!`);
        }
        
        enemies.forEach(e => {
            e.maxHp = e.baseMaxHp;
            e.hp = e.maxHp;
        });
        
        updateAllCharacterUI();
        updatePlayerUI();
        
        await sleep(1000);
        prepareNextPlayerTurn();
    }
    
    async function showAttackVisuals(attacker, target) {
        const attackerSlot = attacker.element;
        const targetSlot = target.element;
        if (!attackerSlot || !targetSlot || !battleSceneElement) return;
        const ray = document.getElementById('attack-ray');
        if (!ray) return;

        attackerSlot.classList.add('attacking-forward');
        await sleep(200);

        const attackerRect = attackerSlot.getBoundingClientRect();
        const targetRect = targetSlot.getBoundingClientRect();
        const sceneRect = battleSceneElement.getBoundingClientRect();
        
        const startX = attackerRect.left + attackerRect.width / 2 - sceneRect.left;
        const startY = attackerRect.top + attackerRect.height / 2 - sceneRect.top;
        const endX = targetRect.left + targetRect.width / 2 - sceneRect.left;
        const endY = targetRect.top + targetRect.height / 2 - sceneRect.top;

        const dx = endX - startX;
        const dy = endY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = (Math.atan2(dy, dx) * 180 / Math.PI) - 90;

        ray.style.height = `${distance}px`;
        ray.style.left = `${startX}px`;
        ray.style.top = `${startY}px`;
        ray.style.transform = `rotate(${angle}deg)`;
        ray.style.opacity = '1';

        AudioManager.playAttack();
        await sleep(200);

        ray.style.opacity = '0';
        attackerSlot.classList.remove('attacking-forward');
        
        await sleep(200);
    }

    // --- ‰∫ã‰ª∂Áõ£ËÅΩ ---
    async function onPlayerCharacterClick(event) {
        const id = event.currentTarget.dataset.id;
        const player = players.find(p => p.id === id);

        if (isExecutingUltimate || !player || player.hp <= 0 || player.mp < player.maxMp) return;
        
        isExecutingUltimate = true;
        const wasPlayerTurn = playerTurnTimerStarted;

        if (wasPlayerTurn) {
            isSwapping = true;
            clearInterval(roundTimer);
            clearInterval(countdownInterval);
        }

        AudioManager.initialize();
        AudioManager.playUltimate();
        logStep(`Áé©ÂÆ∂ ${player.id} ÊñΩÊîæÁµÇÊ•µÊäÄËÉΩ!`);
        
        player.mp = 0;
        updateCharacterUI(player.id);
        
        showFloatingText(player.skill.ultimate.name, player.element);
        const icon = player.element?.querySelector('.char-icon');
        if (icon) icon.classList.add('casting-skill');
        triggerScreenFlash('rgba(252, 163, 17, 0.5)');
        
        await sleep(500); // Animation time
        
        if (icon) icon.classList.remove('casting-skill');
        await player.skill.ultimate.execute(player);
        
        if (wasPlayerTurn) {
            setTimeout(enemyTurn, 500);
        }
        
        isExecutingUltimate = false;
    }

    function setupEventListeners() {
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 't' && e.ctrlKey && e.altKey) {
                const now = Date.now();
                if (now - lastTKeyPressTime < 500) toggleTestMode();
                lastTKeyPressTime = now;
            }
            if (testModeActive && e.ctrlKey) {
                e.preventDefault();
                handleTestCommands(e.key);
            }
        });
        
        document.querySelectorAll('.player-team .character-slot').forEach(slot => {
            slot.addEventListener('pointerdown', onPlayerCharacterClick);
        });

        document.getElementById('restart-button')?.addEventListener('click', resetGame);
    }

    function toggleTestMode() {
        testModeActive = !testModeActive;
        gameWrapper?.classList.toggle('test-mode-on', testModeActive);
        if (testModeIndicator) testModeIndicator.style.display = testModeActive ? 'block' : 'none';
        logStep(`Ê∏¨Ë©¶Ê®°ÂºèÂ∑≤ ${testModeActive ? 'ÂïüÂãï' : 'ÈóúÈñâ'}`);
        if (testModeActive) {
            clearInterval(roundTimer);
            clearInterval(countdownInterval);
        } else {
            prepareNextPlayerTurn();
        }
    }

    function handleTestCommands(key) {
        const { r, c } = lastClickedRunePos;
        if ((r === null || c === null) && !['5','6','7','8','9','l','m'].includes(key)) return;
        if(r === null || c === null) return;
        logStep(`Ê∏¨Ë©¶Êåá‰ª§:Âú®(${r},${c})Âü∑Ë°å Ctrl+${key}`);

        let newRuneData = board[r]?.[c];
        
        switch (key) {
            case '1': if(newRuneData) newRuneData.type = RUNE_STRIPED_H; break;
            case '2': if(newRuneData) newRuneData.type = RUNE_STRIPED_V; break;
            case '3': if(newRuneData) newRuneData.type = RUNE_BOMB; break;
            case '4': if(newRuneData) board[r][c] = { color: undefined, type: RUNE_COLOR_BOMB, status: {} }; break;
            case '5': players.forEach(p => p.hp = 1); updateAllCharacterUI(); break;
            case '6': enemies.forEach(e => e.hp = 1); updateAllCharacterUI(); break;
            case '7': enemies.forEach(e => e.hp = 0); updateAllCharacterUI(); setTimeout(startNextWave, 500); break;
            case '8': players.forEach(p => p.hp = 0); updateAllCharacterUI(); showGameOverScreen(); break;
            case '9': initializeBoard(); break;
            case 'l': playerXP = xpToNextLevel; updateScoreAndXP(0); break;
            case 'm': players.forEach(p => p.mp=p.maxMp); updateAllCharacterUI(); break;
            case 'b': if(newRuneData) newRuneData.burning = !newRuneData.burning; break;
            default: return;
        }
        renderBoard(false);
    }
    
    initializeGame();
});
</script>
<script type="module" src="/index.tsx"></script>
</body>
</html>